# 工程配置
不同于其他的开发指南,一上来就讲解各种语法和技术,本书是以前端工程为出发点,着重强调前端工程的标准化，动手先做出来一个完整的项目, 让代码可以运行, 然后再深入讲解其内部原理.
只有代码先运行起来了,开发者才会有一个直观的感受,通过先模仿,再学习,再模仿,再学习,形成一个学习的正反馈. 

一个前端项目的实践，是从一个完整且标准的前端项目开始的. 不同于10年前的前端开发，一个html(jsp, aspx, php)入口，随意引入多个js和css文件就算是一个前端工程. 现代前端工程跟后端一样，也是一个标准化的模块式开发. 
* 一个前端工程应该是一个独立且标准化的模块，npm在这方面提供了标准.
* 前端开发的现状是代码模块化，并且需要预处理.
    * 对于js来说,无论是JSX, 还是Typescript, 还是ES6,ES7,ES8, 都是需要先编译成主流浏览器可以执行的javascript代码,然后才可以运行。
    * 对于css来说,现在更多的开发都喜欢使用LESS, SASS, Stylus, postcss, 这些也都是需要预编译成css文件,才能在浏览器上运行.
    * 各个浏览器对ES6的支持程度不同, 直接使用原生的ES6, 会遇到跨浏览器的问题.
* 需要工具来管理代码的开发和发布,发布的代码要求性能最优,按需打包.

## npm package
npm (node package management), nodejs包管理方案,它是nodejs工程实际上的包管理标准.
nodejs是使用javascript进行后端开发的利器,它和前端javascript其实是没有什么关系的。
但是实际上,自从有了nodejs以后, 前后端的区分已经不再那么明显, 前端的工程更倾向于将自己的工程整理为一个标准的npm package. 这已经是一个事实上的标准.

任何一个npm package都应该有一个package.json. 它是对于整个工程的描述.

### package.json
下面以一个开源库:immutable.js为例, 来解释package.json
```js
{
  "name": "immutable",
  "version": "4.0.0-rc.9",
  "description": "Immutable Data Collections",
  "license": "MIT",
  "homepage": "https://facebook.github.com/immutable-js",
  "author": {
    "name": "Lee Byron",
    "url": "https://github.com/leebyron"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/facebook/immutable-js.git"
  },
  "bugs": {
    "url": "https://github.com/facebook/immutable-js/issues"
  },
  "main": "dist/immutable.js",
  "module": "dist/immutable.es.js",
  "typings": "dist/immutable-nonambient.d.ts",
  "typescript": {
    "definition": "dist/immutable.d.ts"
  },
  "scripts": {
    ...
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "ts"
    ],
    "transform": {
      "^.+\\.ts$": "<rootDir>/resources/jestPreprocessor.js"
    },
    "testRegex": "/__tests__/.*\\.(ts|js)$",
    "unmockedModulePathPatterns": [
      "./node_modules/react"
    ]
  },
  "devDependencies": {
    ...
  },
  "files": [
    ...
  ],
  "keywords": [
    ...
  ],
  "dependencies": {}
}

```
这个package.json的作用很简单,就是对工程进行描述. 
"name", "version", "description","license", "homepage", "author", "repository", "bugs", ... 等等这些, 看字面意思就应该清楚它的含义. 下面就重点介绍几个属性:
dependencies, devDependencies, version, scripts, main.

#### version

verison是有标准的格式的, 必须要符合SemVer要求. 在这里只强调一点,version是做版本管理用的,它很重要,不能随便修改,需要符合规则和经过组织的审批流程.
> 深入了解详细规则,请参照 [Semantic Versioning Specification](https://semver.org/) (SemVer)

简单总结一下版本号的规则:
  1. 版本号必须是 x.y.z 的形式,x 为 major version, y 为 minor version, z 为patch version. 
  要求x,y,z为非负整数,并且不能是以0开头(0是合法的版本号,但是01不是), x,y,z可以数字递增.
  2. 如果包正式发布了,则该package不可以被修改,否则再次release应该使用新的版本号
  3. 0.y.z 版本号代表处于开发阶段,该package的api可能不稳定.
  4. patch号z发生变更的条件: api未发生变化,只是修复bug.
  5. minor号y发生变更的条件: 引入了新的api,和标注一些废弃的api(仍然可用),变更时,z需要重置为0.
  6. major号x发生变更的条件: 如果API的向后兼容性发生变化, 大版本变更时,y和z需要重置为0.
  7. pre-release version（正式发布前的版本）可以以“-”开始,带一个自定义后缀,后缀字符的取值范围:[0-9A-Za-z-],例子:1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  8. buid metadata(指的是用于标记编译生成一个包的metadata,不同的metadata代表不同的build,它的实际使用不常见) 是以"+"号开始跟在版本号的后面,它不影响版本号,仅仅只表示build的metadata. 例子:1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  9. 版本号的比较规则:（build metadata跟版本比较无关）
    pre-release版本是低于同级的release版本,
    对于pre-release,数字的优先级低于字母,
    同级的长的版本是高于短的版本,直接看例子: 
    1.0.0 < 2.0.0 < 2.1.0 < 2.1.1,
    1.0.0-alpha < 1.0.0,
    1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0,


#### dependencies

这里面表示本工程所有依赖的npm package, 所有的前端第三方库都提供了npm package, 比如 'jquery', 'vue', 'react'等等. 注意:npm package不一定就是第三方的npm package, 我们也可以把自己开发的组件,按照npm标准格式提交到私有的npm服务器上.

在我们引用第三方库的时候,自然会遇到一个问题:版本控制,你需要清楚地知道并且控制你所引入的第三方库的版本. 举个简单的例子,你在自己的工程中引入了jQuery,jQuery 3.x版本是不能兼容IE浏览器的. 如果你依然在开发IE8之类的应用,只能引入1.x版本.
以下就简单总结以下版本运算符的规则:
> 详细规则内容请参见:[semver] (https://docs.npmjs.com/misc/semver)

版本限定符号有很多, 在实际的工程种通常情况下是不会使用通配符来随意指定版本的,所以这里只简单总结一下常见的版本限定符号: ^, ~, <=, >=, <, >, -

  1. 直接给出版本号,匹配精确版本
  2. <, >, <=, >=, - (表示闭包含区间) 
  3. ~表示约等于, 如果指定 x.y.z, 则范围是 >= x.y.z <= x.(y+1).0 , 如果缺失,则相当于缺失部分为x
  4. ^表示兼容版本,按照兼容规则,比如:
  ```nohighlight
    ^1.2.3 := >=1.2.3 <2.0.0  // 大版本变动表示不兼容
    ^0.2.3 := >=0.2.3 <0.3.0  // 大版本为0,表示开发版本,所以兼容版本下移
    ^0.0.3 := >=0.0.3 <0.0.4  // 大版本为0,小版本为0,所以兼容版本以patch为准
  ```
  5. x符号,表示部分统配,缺省的部分,和使用x是等价的,比如:"1" 等价于 “1.x.x”
在区间匹配中,如果指定的是pre-release版本,则只会在该版本下的pre-release中找合适的版本,当x.y.z发生变化,则只会去找正式release的package.
很多情况下,"~"和"^"定位的区间是一样的,但是建议使用"^", 因为它含有版本的兼容的含义,这是"~"所没有的.

#### devDependencies

它和dependencies的区别在于,它表示开发环境中所有依赖的第三方库,仅仅只是开发环境. 我们自己工程代码中不会依赖是不会包含任何这其中的任何一个库. 请务必区分dependencies和devDependencies. 虽然package.json本身是不会做校验,但是请务必严格遵守这个约定.


####  scripts

这里面主要放置是自定义的一些工程脚本命令. 比如: start, build...


####  main
这个是表示,你工程代码的程序入口,如果你将自己的工程需要提交到npm服务器上,则该属性必须指定. 因为其他人在引用的你的package的时候,需要有一个入口才可以被引用到.


#### 其他属性
> 关于npm package.json的详细定义,请参照: [npm package.json] (https://docs.npmjs.com/files/package.json)

在immutable.js的例子中,还用到了其他几个属性:files, module, typings, typescript 和jest. 
其中, 只有files是package.json中的标准属性,它是可选的,作用就是说明本package中必需的文件,它只是一个说明作用,并不是必需的.

其他的几个都是自定义属性:

jest:因为作者引入了jest作代码的单元测试,package.json中的jest项是针对单元测试的配置项.
> 详细内容请参照:[jest] (https://facebook.github.io/jest/docs/en/getting-started.html)

module: 作为es6 module格式的程序的入口.

typings: typings和types等价,主要是针对typescript, 表示以typescript格式的代码作为整个工程的入口, 而非传统的javascript. 某些工程是从头到尾采用typescript开发,它们需要的是typescript的package(TPM, Typescript Definition Package Manager). 指定typings是为了给typescript的开发者提供方便.
同时指定main和typings,表示即支持js方式,也支持ts方式.

typescript.definition,指定一个完全没有依赖项的ts格式的程序入口.

module, typings(types) 和 typescript都是针对typescript而作的配置, 同时配置它们的意图是说明本工程支持三种形式的package, module指定了es6格式的入口,typings指定了typescript格式的入口,main则指定了传统的javascript的入口. 


目前,module, typings(types) 还只是npm标准的提案,还未形成正式的标准,未来使用typescript的开发者多了,这是很有希望成为标准的.


### 小结
软件的开发,实际上就是一个模块,一个模块的组装起来的. 
在你项目里总会或多或少的用到别人开发的模块,同时你开发的模块也会被别人所引用.
npm就是前端工程模块化的标准.

关于package.json的详细内容如下：
https://docs.npmjs.com/files/package.json
