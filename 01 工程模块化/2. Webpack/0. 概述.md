# 概述
代码打包是生产环节中的一个必不可少的环节，实际上打包工具有很多：webpack, parcel, rollup, prepack等. (gulp并不是一个打包工具，它只是一个自动化工具.)
在这众多的打包工具中，webpack目前是处于绝对主流地位.所以，这里只详细讲解webpack，如果对其他的打包工具感兴趣，可以自己去查阅.

webpack当前的版本是 4.15.0
安装：
```cmd
npm install --D webpack
npm install --D webpack-cli
```

webpack一个非常开放的工具，同时也意味着它的配置非常复杂, 以至于需要专门花时间去学习掌握它.
换个角度，可以这样理解：当一种工具的配置复杂到一定的程度的时候，实际上就可以认为这种工具是一种编程语言了，比如，可以认为c++编译器提供给你的配置就是各种数据类型，条件语句，语法等等，你写的c++代码就相当于在写编译器的配置，然后编译运行配置(代码)就是想要的程序.
 

这里按照webpack配置的必要程度，这里将webpack配置分为5个等级：
1. 基础配置
2. loader配置
3. 开发library的配置
4. 拆分优化bundle的配置
5. 开发配置(dev-server)
然后逐层渐进去掌握它的核心配置如何使用.


# 基本原理
webpack的官方定义是 dependency graph bundler.
在webpack中，一个文件就是一个 module, 具体来源如下：
* 1. ES6 import
* 2. CommonJS require
* 3. AMD define 和 require
* 4. css/sass/less @import
* 5. 样式中 url()
* 6. HMTL文件中 "<img src=...>"

试想一下，webpack的工作流程：
1. 从工程的入口js文件开始，寻找任何以上6种用法的地方，找出依赖项.
2. 在依赖项的文件中，继续寻找任何以上6种用法的地方，依次遍历，直到依赖单向图结束.
3. 根据文件的绝对路径，每个相同的文件在依赖图上，只属于一个节点.
4. 构建依赖图的过程一定是一个静态过程，而非动态过程. 不能对import之类的语句使用if, 这是几乎所有语言的默认惯例.

如果代码中的循环依赖错误，有可能会导致webpack打包报错. 实际上并不不会，webpack设计得非常健壮，但不管怎么样，循环依赖是个低级的代码错误，任何时候都要避免.

## resolve 和 loader
resolve 和 loader 是webpack中出现频率最高的两个名词：
* loader： 解析不同类型的文件，如果不做任何plugin设置，最终结果是js，除了资源文件以外的.
* resolve：处理文件寻址的问题.
loader在解析文件内容时，第一件要做的事情是找出该文件中存在的依赖项. 然后交给resolver去找到该文件. resovler解决的问题就是找到唯一确定的文件路径. 
webpack使用 enhance-resolve 来处理文件寻址的问题. https://github.com/webpack/enhanced-resolve











导入csv和tsv数据，可以使用csv-loader
导入xml数据，可以使用xml-loader

# HtmlWebpackPlugin （html-webpack-template）
生成index.html文件，自动导入依赖文件.

# CleanWebpackPlugin
生成之前，首先清理dist目录.

# WebpackManifestPlugin
抽取manifest数据到一个json文件.



# code splitting & lazy load
三种拆分打包的方法：
1. 使用entry配置拆分. (公共模块会在每个模块中都存在)
2. 使用CommonsChunkPlugin.
3. 动态import.

使用第一种方法加上第二种:
```js
entry: {
    app: './src/index.js'
    other: './src/other.js'
},
output: {
    filename: '[name].bundle.js'
    chunkFilename: '[name].bundle.js'
},
plugins: [
    new webpack.optimize.CommonsChunkPlugin({
        name: 'common' // 抽出来的公共模块的名字
    })
]

```

还有三种Plugin： ExtractTextPlugin， bundle-loader, promise-loader(和bundle-loader功能类似，区别是支持promise)

动态加载, 使用webpackChunkName注释会指定打包的名称, 否则会生成 [id].js
```js
var element = document.createElement('div');
const _ = await import(/* webpackChunkName: "lodash" */ 'lodash');
element.innerHTML = _.join(['Hello', 'webpack'], ' ');
return element;


// sample 2
button.onclick = e => import(/* webpackChunkName: "print" */ './print').then(module => {
    var print = module.default;

    print();
});

```

webpack有高级特性preload和prefetch

Bundle Analysis 打包分析工具：
webpack-chart
webpack-visualizer
webpack-bundle-analyzer



## 框架的lazy load方案：
1. Vue：https://alexjoverm.github.io/2017/07/16/Lazy-load-in-Vue-using-Webpack-s-code-splitting/
2. React：https://reacttraining.com/react-router/web/guides/code-splitting



# development 环境
```js
devtool: 'inline-source-map'
```
3种开发工具：
1. webpack --watch
2. webpack-dev-server (支持热更新)， HotModuleReplacementPlugin
```js
devServer: {
    contentBase: './dist',
    hot: true
}
plugins: [
    new webpack.NamedModulesPlugin(),   // 方便查看依赖
    new webpack.HotModuleReplacementPlugin()
]

// 运行
webpack-dev-server --open
```
3. webpack-dev-middleware (包含了文件热更新的模块，适合定制server，比如模拟websocket)
依赖：webpack-hot-middleware
```js
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

// Tell express to use the webpack-dev-middleware and use the webpack.config.js
// configuration file as a base.
app.use(webpackDevMiddleware(compiler, {
  publicPath: config.output.publicPath
}));

// Serve the files on port 3000.
app.listen(3000, function () {
  console.log('Example app listening on port 3000!\n');
});
```


# tree shaking 打包时剔除没有使用的 export
设置为false, webpack会自动清除没有使用到的内容.
```js
// package.json
sideEffects: false

```
不想进行tree shaking 的部分可以如下，并且可以在各个loader种配置.
```js
{
  "name": "your-project",
  "sideEffects": [
    "./src/some-side-effectful-file.js",
    "*.css"
  ]
}
```

# minify
```js
mode: "production"
```
压缩js的plugin有：
1. UglifyJSPlugin
2. BabelMinifyWebpackPlugin
3. ClosureCompilerPlugin
```js
devtools: 'source-map',
plugins: [
    new UgligyJSPlugin({
        sourceMap: true
    }),
    new webpack.DefinePlugin({
        'process.env.NODE_ENV': JSON.stringify('production')
    })
]
```




























