# chunk的数据结构设计
## chunk id 和 module id
chunk id：对应每个chunk文件自己的id.
module id: 对应chunk文件中的module id, 通过lazy load加载完成后，它最终会汇入到module集合里进行统一管理.
真实的lazy load 调用的代码如下：
```js
__webpack_require__.e(/* import() */ 0).then(__webpack_require__.t.bind(null, 2, 7)).then(function (_ref) {
    ...
}
```
说明：
1. __webpack_require__.e(0)： 
这里面的 0 代表是chunk id, 它的作用是根据它能找到指定的chunk 文件.
2. __webpack_require__.t.bind(null, 2, 7)):
这里面的 2 表示的是chunk文件中的 module id，它是在整个bundle中在全局唯一的，不能有冲突.
至于这里的7只是 __webpack_require__.t 函数的扩展参数，这里暂时可以忽略它.

### chunk文件结构
```js
(window["webpackJsonp"] = window["webpackJsonp"] || []).push(
    [
        [0],        // chunk id
    {
        2: (function(){...})  // 数字表示module id, modul函数 部分
    }
]);
```
chunk文件里的核心内容分为两部分：
1. [0]: 表示chunkId集合, 之所以设计成数组是为了方便扩展.
2. {2:(function(){...})}: 存放module函数部分，对应的key表示全局(整个bundle范围)唯一的module Id.

说明：
1. window["webpackJsonp"].push 并不是调用 Array.prototype.push, 而webpack runtime 中的 webpackJsonpCallback 函数.
正是因为使用了这个技巧，所以才实现了promise形式的lazy load.
2. script元素上的onload仅仅只是为了错误处理和状态重置.