# output

## 1. 核心配置

### path 指定输出路径
### filename 指定js文件的输出名称
默认情况下，不做任何配置的话，css和资源文件(base64的形式)都会打包进js文件，当加载该js文件时，在DOM中动态创建style.
在配置filename时，可以使用如下的替换模板字符串：
* [name]: 对应entry中的取的模块名
* [hash]: 每次构建过程中，唯一的hash
* [chunkhash]: 基于每个chunk内容的hash
* [id]: 内部的chunk id
* [query]: 模块的query，例如，文件名？后面的字符串

[hash] 和 [chunkhash] 的长度可以使用[hash:16]来指定(默认20).
或者，通过指定[output.hashDigestLength]来配置全局长度.
在使用ExtractTextWebpackPlugin时，可以使用[contenthash].

注意：此选项不会影响那些按需加载chunk的输出文件.对于那些文件，请使用[output.chunkFilename] 来控制输出. 通过loader创建的文件也不受影响. 在这种情况下，必须尝试loader的选项，比如, MiniTextPlugin等.

### publicPath 默认值是 ""
对于按需加载(on-demand-load)或加载外部资源来说，publicPath是一个非常重要的选项. 比如，css中的url路径是相对于css文件，而html或js中引用资源文件，则是相对于html文件. 还有一种相对协议路径，如 https和http.

webpack-dev-server 也会默认从 publicPath为基准，启动web服务.
例子：
```js
publicPath: "https://cdn.example.com/assets/", // CDN（总是 HTTPS 协议）
publicPath: "//cdn.example.com/assets/", // CDN (协议相同)
publicPath: "/assets/", // 相对于服务(server-relative)
publicPath: "assets/", // 相对于 HTML 页面
publicPath: "../assets/", // 相对于 HTML 页面
publicPath: "", // 相对于 HTML 页面（目录相同）
```

### chunkFilename 默认为 '[id].js'
此选项决定了非入口(non-entry)chunk文件的名称.
注意，这些文件名需要在runtime根据chunk发送的请求去生成.
因此，需要在webpack runtime输出bundle值时，将chunk id的值对应映射到占位符(如[name]和[chunkhash]).这会增加文件大小，并且在任何chunk的占位符值修改后，都会使bundle失效.
默认使用[id].js，或从 output.filename 中推断出的值 ([name]会被预先替换为[id] 或 [id].)


### library 相关配置
在开发js类库的时候，最后通常需要输出一个全局变量以方便使用，例如，jquery会有个一个$, lodash会有一个_.
以下三个配置，就是为了解决这个问题.

#### library: 指定暴露出来的全局变量名
在libraryTarget为umd时，可以指定为一个对象，针对不同的环境使用不同的名称.
#### libraryTarget
1. 默认为 'var'
表示当library加载完成，入口起点的返回值将分配给一个变量:
```js
var MyLibrary = _entry_return_;

// 在一个单独的 script……
MyLibrary.doSomething();
```
注意：当 output.library 设置为空时，会因为没有变量无法赋值.
2. 'assign':
将产生一个隐含的全局变量，可能会潜在地重新分配到全局变量中已存在的值（谨慎使用）
```js
MyLibrary = _entry_return_;
```
注意：当 output.library 设置为空，将产生一个破损的输出bundle.
3. 赋值到指定对象上
```js
(function(e, a) { for(var i in a) e[i] = a[i]; }(${output.libraryTarget}, _entry_return_)
```
* libraryTarget: 'this', 入口起点的返回值将分配值给this的一个属性.
```js
this["MyLibrary"] = _entry_return_;
// 在一个单独的 script……
this.MyLibrary.doSomething();
MyLibrary.doSomething(); // 如果 this 是 window
```
* libraryTarget: 'window'
* libraryTarget: 'global'
* libraryTarget: 'commonjs'
```js
exports["MyLibrary"] = _entry_return_;
require("MyLibrary").doSomething();
```
* libraryTarget: 'commonjs2', 它跟'commonjs'的区别是它把输出导入到module.exports, 而不是 exports上. 注意：output.library 会被省略.
commonjs 和 commonjs2 的区别：
CommonJs spec defines only exports. But module.exports is used by node.js and many other CommonJs implementations.
commonjs mean pure CommonJs
commonjs2 also includes the module.exports stuff.

* libraryTarget: 'amd'
AMD 模块要求入口chunk(<script/>加载的第一个脚本)通过特定的属性定义，例如 define 和 require, 它们通常由 RequireJs 提供.
例子：
```js
output: {
  library: "MyLibrary",
  libraryTarget: "amd"
}
// 输出的内容如下：
define("MyLibrary", [], function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});

// 使用该 library 的时候：
require(['MyLibrary'], function(MyLibrary) {
  // 使用 library 做一些事……
});
```

* libraryTarget: 'umd'
将library暴露为所有模块下定义都可以运行，commonjs，AMD，或将模块导出到global下的变量.
例子：
```js
output: {
  library: "MyLibrary",
  libraryTarget: "umd"
}

// 输出
(function webpackUniversalModuleDefinition(root, factory) {
  if(typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if(typeof define === 'function' && define.amd)
    define([], factory);
  else if(typeof exports === 'object')
    exports["MyLibrary"] = factory();
  else
    root["MyLibrary"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
  return _entry_return_; // 此模块返回值，是入口 chunk 返回的值
});
```
注意, 省略 library 会导致入口起点的所有属性，直接赋值给root对象.
可以给library指定为一个对象(只能是umd的情况)，针对不同的环境使用不同的名称：
```js
output: {
  library: {
    root: "MyLibrary",
    amd: "my-library",
    commonjs: "my-common-library"
  },
  libraryTarget: "umd"
}
```
#### libraryExport
默认为： _entry_return_
以libraryTarget为默认值var为例，说明配置不同值的效果：
1. libraryExport: "default"
```js
// if your entry has a default export of `MyDefaultModule`
var MyDefaultModule = _entry_return_.default;
```
2. libraryExport: 'MyModule'
```js
var MyModule = _entry_return_.MyModule;
```
3. libraryExport: ["MyModule", "MySubModule"]
```js
var MySubModule = _entry_return_.MyModule.MySubModule;
```

Question: module.exports.default?


## 2. 高级配置 （通常情况，使用默认即可）

pathinfo
chunkFilename
jsonpFunction
sourceMapFilename

devtoolModuleFilenameTemplate
devtoolFallbackModuleFilenameTemplate

umdNamedDefine

crossOriginLoading


### hashDigest： 默认为'hex'， 支持nodejs hash.digest 的所有编码
### hashDigestLength： 默认20, 散列摘要长度.
### hashFunction: 默认为 'md5'，也可以传入自定义函数. 
支持nodejs crypto.createHash 的所有功能.
### hashSalt: 一个可选的加盐值，通过nodejs hash.update 来更新hash.




## 3. 骨灰级配置 （你可能并不需要知道它们的存在）

devtoolLineToLine
hotUpdateMainFilename
hotUpdateChunkFilename
sourcePrefix
