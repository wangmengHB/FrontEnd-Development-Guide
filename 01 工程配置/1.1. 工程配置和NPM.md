# 工程配置
不同于其他的指南，一开始就讲解各种语法和技术，本书是以前端工程为出发点，着重强调动手先做出来，让代码可以运行，然后再深入讲解其内部原理.
只有代码先运行起来了，开发者才会有一个直观的感受，通过先模仿，再学习，再模仿，再学习，形成一个学习的正反馈.

之所以先讲解工程配置技术，这里面有一个重要的原因：
* 前端开发的趋势，越来越倾向于代码需要预编译，
    * 对于js来说，无论是JSX, 还是Typescript, 还是ES6,ES7,ES8, 都是需要先编译成浏览器可以执行的javascript代码，然后才可以运行。
    * 对于css来说，现在更多的开发都喜欢使用LESS, SASS, postcss, 这些也都是需要预编译成css文件，才能在浏览器上运行.
    * 各个浏览器对ES6的支持程度不同, 直接使用原生的ES6, 会遇到跨浏览器的问题.
* 需要工具来管理代码的开发和发布，发布的代码要求性能最优，按需打包

如果一开始上来就学习各种技术，但是始终没有一个动手的机会，学习效果会大打折扣. 开发终究注重的还是动手，学习webpack就是为了搭建一个开发环境，先让代码运行起来.

OK, Let's get started!

## 准备知识: npm package
npm (node package management), nodejs包管理方案，它是nodejs工程实际上的包管理标准.
nodejs是使用javascript进行后端开发的利器，它和前端javascript其实是没有什么关系的。
但是实际上，自从有了nodejs以后，前后端的区分已经不再那么明显，前端的工程更倾向于将自己的工程整理为一个标准的npm package. 这已经是一个事实上的标准.

任何一个npm package都应该有一个package.json.
它是对于整个工程的描述.

### package.json： 一个工程，一个package.json
下面以一个开源库：immutable.js为例, 来解释package.json
```
{
  "name": "immutable",
  "version": "4.0.0-rc.9",
  "description": "Immutable Data Collections",
  "license": "MIT",
  "homepage": "https://facebook.github.com/immutable-js",
  "author": {
    "name": "Lee Byron",
    "url": "https://github.com/leebyron"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/facebook/immutable-js.git"
  },
  "bugs": {
    "url": "https://github.com/facebook/immutable-js/issues"
  },
  "main": "dist/immutable.js",
  "module": "dist/immutable.es.js",
  "typings": "dist/immutable-nonambient.d.ts",
  "typescript": {
    "definition": "dist/immutable.d.ts"
  },
  "scripts": {
    ...
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "ts"
    ],
    "transform": {
      "^.+\\.ts$": "<rootDir>/resources/jestPreprocessor.js"
    },
    "testRegex": "/__tests__/.*\\.(ts|js)$",
    "unmockedModulePathPatterns": [
      "./node_modules/react"
    ]
  },
  "devDependencies": {
    ...
  },
  "files": [
    ...
  ],
  "keywords": [
    ...
  ],
  "dependencies": {}
}

```
这个package.json的作用很简单，就是对工程进行描述. 
"name", "version", "description","license", "homepage", "author", "repository", "bugs", ... 等等这些，看字面意思就应该清楚它的含义，这些没什么好解释的. 下面就重点介绍几个属性:
dependencies, devDependencies, version, scripts, main.

##### version

verison是有标准的格式的，必须要符合SemVer要求，深入了解详细规则，请参照如下：
> [Semantic Versioning Specification](https://semver.org/) (SemVer)
简单总结一下版本号的规则：
1. 版本号必须要准确
2. 版本号必须是 x.y.z 的形式，x 为 major version, y 为 minor version， z 为patch version. 
要求x,y,z为非负整数，并且不能是以0开头(0是合法的版本号，但是01不是), x,y,z可以数字递增.
3. 如果package release，则该package不可以被修改，否则再次release应该使用新的版本号
4. 0.y.z 版本号代表处于开发阶段，该package的api可能不稳定.


    5. Version 1.0.0 defines the public API. The way in which the version number is incremented after this release is dependent on this public API and how it changes.

    6. Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior.

    7. Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards compatible functionality is introduced to the public API. It MUST be incremented if any public API functionality is marked as deprecated. It MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes. Patch version MUST be reset to 0 when minor version is incremented.

    8. Major version X (X.y.z | X > 0) MUST be incremented if any backwards incompatible changes are introduced to the public API. It MAY include minor and patch level changes. Patch and minor version MUST be reset to 0 when major version is incremented.

    9. A pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version. Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes. Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.

    10. Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version. Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-]. Identifiers MUST NOT be empty. Build metadata SHOULD be ignored when determining version precedence. Thus two versions that differ only in the build metadata, have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.

    11. Precedence refers to how versions are compared to each other when ordered. Precedence MUST be calculated by separating the version into major, minor, patch and pre-release identifiers in that order (Build metadata does not figure into precedence). Precedence is determined by the first difference when comparing each of these identifiers from left to right as follows: Major, minor, and patch versions are always compared numerically. Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. When major, minor, and patch are equal, a pre-release version has lower precedence than a normal version. Example: 1.0.0-alpha < 1.0.0. Precedence for two pre-release versions with the same major, minor, and patch version MUST be determined by comparing each dot separated identifier from left to right until a difference is found as follows: identifiers consisting of only digits are compared numerically and identifiers with letters or hyphens are compared lexically in ASCII sort order. Numeric identifiers always have lower precedence than non-numeric identifiers. A larger set of pre-release fields has a higher precedence than a smaller set, if all of the preceding identifiers are equal. Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.

在这里只强调一点，version是做版本管理用的，它很重要，不能随便修改，需要领导批准.

##### dependencies

这里面表示本工程所有依赖的npm package, 所有的前端第三方库都提供了npm package, 比如 'jquery', 'vue', 'react'等等. 注意：npm package不一定就是第三方的npm package, 我们也可以把自己开发的组件，按照npm标准格式提交到私有的npm服务器上.

##### devDependencies

它和dependencies的区别在于，它表示开发环境中所有依赖的第三方库，仅仅只是开发环境. 我们自己工程代码中不会依赖是不会包含任何这其中的任何一个库. 请务必区分dependencies和devDependencies. 虽然package.json本身是不会做校验，但是请务必严格遵守这个约定.

版本号的运算：
>
简单总结一下常见的版本限制符号： ^, ~, <=, >=, <, >

    ^1.2.x := >=1.2.0 <2.0.0
    ^0.0.x := >=0.0.0 <0.1.0
    ^0.0 := >=0.0.0 <0.1.0
    
    ^1.2.3 := >=1.2.3 <2.0.0
    ^0.2.3 := >=0.2.3 <0.3.0
    ^0.0.3 := >=0.0.3 <0.0.4
    ^1.2.3-beta.2 := >=1.2.3-beta.2 <2.0.0 Note that prereleases in the 1.2.3 version will be allowed, if they are greater than or equal to beta.2. So, 1.2.3-beta.4 would be allowed, but 1.2.4-beta.2 would not, because it is a prerelease of a different [major, minor, patch] tuple.
    ^0.0.3-beta := >=0.0.3-beta <0.0.4 Note that prereleases in the 0.0.3 version only will be allowed, if they are greater than or equal to beta. So, 0.0.3-pr.2 would be allowed.

    1.2 - 2.3.4 := >=1.2.0 <=2.3.4
    1.2.3 - 2.3 := >=1.2.3 <2.4.0


    
    ~1.2.3 := >=1.2.3 <1.(2+1).0 := >=1.2.3 <1.3.0
    ~1.2 := >=1.2.0 <1.(2+1).0 := >=1.2.0 <1.3.0 (Same as 1.2.x)
    ~1 := >=1.0.0 <(1+1).0.0 := >=1.0.0 <2.0.0 (Same as 1.x)
    ~0.2.3 := >=0.2.3 <0.(2+1).0 := >=0.2.3 <0.3.0
    ~0.2 := >=0.2.0 <0.(2+1).0 := >=0.2.0 <0.3.0 (Same as 0.2.x)
    ~0 := >=0.0.0 <(0+1).0.0 := >=0.0.0 <1.0.0 (Same as 0.x)
    ~1.2.3-beta.2 := >=1.2.3-beta.2 <1.3.0 Note that prereleases in the 1.2.3 version will be allowed, if they are greater than or equal to beta.2. So, 1.2.3-beta.4 would be allowed, but 1.2.4-beta.2 would not, because it is a prerelease of a different [major, minor, patch] tuple.

#####  scripts

这里面主要放置是自定义的一些工程脚本命令.


#####  main
这个是表示，你工程代码的入口，如果你将自己的工程需要提交到npm服务器上，则该属性必须指定. 因为其他人在引用的你的package的时候，需要有一个入口才可以被引用到.




