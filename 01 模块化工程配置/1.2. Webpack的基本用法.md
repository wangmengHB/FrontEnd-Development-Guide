# webpack

下面开始介绍webpack,webpack的作用是把各个模块给连接起来.
webpack的官方解释是: dependency graph bundler.

webpack是目前最主流的前端开发依赖项管理和打包工具. 除了webpack以外,还有其他的工具能完成这些工作,其中,gulp偏向自动化流程,rollup是最新的打包工具.

在实际的项目,出于风险考虑,我们应该采用最主流的技术,同时对于最新的技术保持关注态度. 
对于webpack, gulp, rollup这三种工具的态度是:
* 完全掌握的并且熟练使用webpack
* gulp可选,根据开发过程中的自动化的需求来决定是否使用
* 了解关注和学习rollup

## webpack的命令行用法
```
// 根据webpack.conf.js中的配置，执行打包命令
webpack --config webpack.conf.js

// 根据webpack.conf.js中的配置，实时进行打包
webpack --watch --config webpack.conf.js
```
学会使用webpack，其实就是指学会配置webpack.

webpack还有一些更高级的使用方法，在nodejs的脚本中直接require('webpack')，然后按照自定义脚本的方式来运行webpack的打包指令或者实时打包指令. 这种方法常见于gulp自动化中.

## webpack配置
### 1. entry (指定工程入口)
最简单的用法就是直接设置：
```js
entry: {
    app: './src/index.js'
}
```
属性名就是该包的名字，可以自己定义，或者从某个配置文件中读取，属性值就是工程的入口文件.

这只是一种最简单的用法，它会把包打成了一个文件，但是现实中我们往往会考虑如下问题:
1. 不要将第三方库文件也打入到包里
2. 默认情况下，webpack会把css文件打入到js文件中，通常情况下，我们希望把css文件抽出来.
2. 分模块打成多个包，而不希望将所有的文件都打成了一个文件，导致这个文件过大.
这些问题会在后面的章节里详细说明解决方案.

### 2. output (指定打包文件的输出)
最简单的设置如下：
```js
output: {
    path: path.join(__dirname, '../public/dev') 
    filename: 'js/[name].js',
    publicPath: '/',
}
```
这里只说明两个需要注意的地方：
1. filename中的[name]即是在entry中指定的属性名，自定义的工程名字.
2. 指定publicPath是有原因的，因为浏览器在获取css中引用的资源是以css为相对路径的，但是js中引用的资源是以html为相对路径，指定publicPath的目的是将相对路径变为publicPath的绝对路径.

### 3. module (配置各种loader)
webpack本身只能识别javascript，对于css，资源文件，typescript，jsx, flow等等，webpack是不识别的，需要配置相应的loader来处理对应类别的文件. 一种loader对应了一种类型的文件的解析.

1. 处理js的loader：babel-loader(babel-core), ts-loader, coffee-loader, coffee-redux-loader, json-loader, json5-loader, i18n-loader, yaml-frontmatter-loader.
2. 处理css的loader： style-loader, css-loader, sass-loader(node-sass), less-loader, postcss-loader, autoprefix-loader.
3. 处理资源文件的loader: file-loader, url-loader, gzip-loader, raw-loader.

例子:
```js
module: {
    rules: [{
        test: /\.jsx?$/,
        exclude: /node_modules/,
        loader: 'babel-loader'
    }, {
        test: /\.(svg|jpeg|png|jpg|gif)$/,
        loader: 'file-loader',
        options: {
            name: '[name]-[hash].[ext]',
            outputPath: 'asset/'
        } 
    }, {
        test: /\.scss$/,
        use: ExtractTextPlugin.extract({
            fallback: 'style-loader',
            use: ['css-loader', 'sass-loader']
        })
    }, {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
            fallback: 'style-loader',
            use: ['css-loader']
        })
    }]
},
```
关于这个例子有两点补充说明：
1. 这里使用了babel-loader来transpile ES和jsx代码，关于babel-loader还需要做一些配置，.babelrc里面设置该如何转译ES和JSX文件.
babel-loader 依赖 babel-core.
2. 关于css文件的处理，sass-loader处理完了，然后是css-loader, 最后是style-loader.
只有通过style-loader，css文件才能成功的打包进入js文件，通过ExtractWebpackTextPlugin来把css部分抽离成独立的css文件.

### 4. plugin
有4种情况需要使用plugin：
1. 抽离出css文件: Extract-Webpack-Text-Plugin

默认情况下，webpack打包出来的文件只是一个js文件，所有的css资源都包含其中，当浏览器加载该css文件的时候，会动态的在DOM中创建style节点，插入css内容.

2. 区分开发环境还是生成环境: webpack.DefinPlugin

很多第三方在代码中都是区分开发环境和生产环境的，比如在开发环境中输出更多的日志方便调试，生产环境中的代码更高效和干净. 在生产环境和开发环境，代码走的分支是不同的.

3. 压缩css文件和js文件

4. 分离第三方库以及将工程打包成多个文件.

关于这些场景会在后面的章节中逐个的深入去探讨.

## 小结

学会webpack，最核心的内容就是学会如何配置webpack: entry, output, module, plugins.