# webpack 如何打包js文件？
由webpack打包后的js文件的结构如下：
```js
(function(modules){ // webpackBootstrap
    ...
    // 39: 表示entry的那个js文件，即第40个module是入口module.
    return __webpack_require__(__webpack_require__.s = 39);

})([
    module1,
    module2,
    module3,
    ...
])
```
一个自执行函数，并且该函数的其输入参数就是各个module，即每一个js/css/或其他的资源文件. 这个自执行函数称为webpackBootstrap函数. 
这个自执行函数的最后一句是加载作为entry的那个js文件(module)。

## webpackBootstrap函数
```js
var installedModules = {};
__webpack_require__ = function(moduleId) {...}	 	// function
__webpack_require__.m = modules;				// modules
__webpack_require__.c = installedModules;			// installedModules
__webpack_require__.p = '';			  // 保存一个public path	
// 一些工具方法
// hasOwnProperty
__webpack_require__.o = function(object, property) { 
return Object.prototype.hasOwnProperty.call(object, property); 
};
// define getter
__webpack_require__.d = function(exports, name, getter) {
    if(!__webpack_require__.o(exports, name)) {
        Object.defineProperty(exports, name, {
            configurable: false,
            enumerable: true,
            get: getter
        });
    }
};
// 这两个方法主要用于下面，
// 定义一个getter 函数，返回module.exports，并且 该函数定义属性a的getter为该函数，
// 意思就是， getter函数.a 里保存的就是module.exports。
// a是不可删除的.
// 暂时没有看到 __webpack_require__.n的调用地方，可能只是应对复杂情况的备用.	
__webpack_require__.n = function(module) {
    var getter = module && module.__esModule ?
        function getDefault() { return module['default']; } :
        function getModuleExports() { return module; };
    __webpack_require__.d(getter, 'a', getter);
    return getter;
};

```
这个函数中最重要的部分就是__webpack_require__函数，在这个函数中同时挂了一些属性：
1. __webpack_require__.m： 所有的module.
2. __webpack_require__.c： 已经加载完的module
3. __webpack_require__.p： 这个就是webpack config中配置的publicPath.
4. __webpack_require__.s： 表示作为程序入口的那个module的序号.
其他还定义了三个放置工具函数的属性，用来处理非标准module的兼容问题，并非它的核心内容， 暂时可以忽略这个问题.

## __webpack_require__函数
```js
 function __webpack_require__(moduleId) {

    // Check if module is in cache
    if(installedModules[moduleId]) {
        return installedModules[moduleId].exports;
    }
    // Create a new module (and put it into the cache)
    var module = installedModules[moduleId] = {
        i: moduleId,
        l: false,
        exports: {}
    };

    // Execute the module function
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    // Flag the module as loaded
    module.l = true;

    // Return the exports of the module
    return module.exports;
}

```
这个函数很简单，只是使用了一个缓存机制，加载过的module不再重复加载. 其中最核心的内容，执行了module函数，并且把__webpack_require__函数注入其中.

## module函数：
module函数实质上就是webpack封装了一层的单个js文件(或其他文件), 一个文件就是一个module函数.
```js
function(module, exports, __webpack_require__) {
'use strict';
Object.defineProperty(exports, "__esModule", {
value: true
});
exports.default = xxx;

// module中如果有引用到其他的module：
var _depend = __webpack_require__(2);
var _depend2 = _interopRequireDefault(_depend);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 调用的过程：
(0, _depend2.default)();
...

}
```
说明一下module函数这三个输入参数：
1. module 指的是这个module函数自身.
2. exports 指的是 module.exports, 即是这个module的导出部分.
3. __webpack_require__指代的是webpackBootstrap函数中注入的那个函数.
之所以将__webpack_require__函数传进去，是因为各个module中可能会引用到其他的module, 并且会执行需要引用的module函数(或缓存)，并且返回所需module.exports.

## 小结
理解了以上三个函数，基本上就算是理解了整个webpack的工作原理了，webpack实际上只是一个依赖项的打包工具，默认情况下只认识js文件. 每个文件都会封装成一个module函数，每个module都有一个module.exports, __webpack_require__函数执行完会返回这个module.exports.

实际上，真实工程中使用webpack打包出来的文件要比这个复杂，还有各种非js文件module的加载也参杂其中，同时还要区分开发环境和生产环境.