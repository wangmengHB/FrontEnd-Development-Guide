# tsconfig.json 和 tsc
对于任何使用 ts 编写的项目，都需要配置 tsconfig.json. 
通常情况下，我们的项目有很多种：
1. 纯函数库项目，发布的结果为一个 npm 包.
2. 基于 react 或 vue 的组件库项目，发布的结果也为一个 npm 包，或者还会在 cdn 上发布一个 js/css.
3. 应用项目发布的结果是 js/css ，发布到 cdn 或者 web 服务器. 

对于第一类项目来说，我们可以只使用 tsc 作为唯一的编译工具，并不需要 webpack 和 babel，因为最终输出的仅仅只是一个 npm 包，它只能在其他前端开发工程 或 nodejs 中被人使用，不需要考虑浏览器的兼容性问题，更不需要打包压缩。  
注意：
1. 建议将 compilerOptions.target 设置为 es5，通常外部工程不会对 node_modules 中的代码进行转译。
2. 建议编译两次，输出一份 commonjs（compilerOptions.module） 作为 package.json 的 main 入口；输出一份 es6 作为 package.json 的 module 入口。
输出两次的配置通常不写在 tsconfig.json 中，通过指定 tsc 命令行工具的参数来实现：
```json
{
  "main": "dist/index.js",
  "module": "lib/index.js",
  "typings": "lib/index.d.ts",
  "files": [
    "dist",
    "lib"
  ],
  "scripts": {
    "build": "rm -rf dist && rm -rf lib && tsc --outDir './lib' --m 'es6' && tsc --outDir './dist' --m 'commonjs'",
    "prepublish": "npm run build",
    "test": "NODE_PATH=./ mocha --ui tdd"
  },
}
```

对于其他两种类型的工程，通常不会使用 tsc 作为直接的编译工具，通常使用 ts-loader 来配合 webpack 进行打包。
通常的 ts 文件解析的顺序是 ts-loader -> babel-loader, 原因很简单，因为 ts 只会将代码转译为符合 es 标准的代码，但是浏览器对 es 标准支持是参差不齐，使用 babel-loader 再处理一次 ts 解析的产物是有必要的，因为最终的代码需要是运行在浏览器上。
另外还有一点，ts 中的路径别名特性没有 webpack 里好用，如果直接使用 ts 别名特性编译后的代码，不是直接可用的。

# tsconfig.json compilerOptions 详解
tsconfig.json 的配置项目基本可以分为以下几大类：
1. 文件输出相关   
2. 运行时需要的 lib
3. 类型检查约束项

## 1. 文件输出相关
## noEmit, outDir, include/exclude, target, module, sourceMap, removeComments, declaration, 
* noEmit: 如果为 true，则不输出任何文件   
* outDir: 指定编译完输出文件的目录    
* include/exclude: 指定哪些文件需要编译, 哪些文件不需要编译，支持 glob 语法通配符。
* target: 指定输出的 js 符合标准，通常指定为 ES5，
在 webpack 多 loader 情况下，通常会指定 ESNext（或 ES6）, 最后一步交给 babel-loader。
* module: 指定输出的文件是 AMD/UMD/ES6/COMMONJS/SYSTEM.
建议只使用 commonjs 和 es6，其他的编辑结果通常不能直接使用。
* removeComments：输出的文件中是否移除注释   
* sourceMap: 是否输出 sourceMap 
* declaration: 是否输出 .d.ts 文件




## baseUrl, paths
谨慎使用 ts 的 baseUrl 和 paths 特性，因为在使用 tsc 输出的文件中，文件路径并不不会替换掉。 需要额外编写脚本解决这个问题。

https://github.com/microsoft/TypeScript/issues/9910#issuecomment-234729007
> 
  The compiler does not rewrite module names. module names are considered resource identifiers, and are mapped to the output as they appear in the source

  The module names you write are not going to change in the output. the "paths" and "baseURL" are there to tell the compiler where they are going to be at runtime.

对于 ts 的 npm 项目，可以在 test.ts 中使用路径别名特性。 注意需要在 package.json 的 scripts 中测试指令中指定 NODE_PATH.
```json
"scripts": {
  "test": "NODE_PATH=./ mocha --ui tdd"
},
```

# 运行时需要的
## lib: 

## 类型检查相关约束
### 


