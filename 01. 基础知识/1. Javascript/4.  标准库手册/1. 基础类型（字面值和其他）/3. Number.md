# Number
## Number 的全局静态属性
* Number.EPSILON: 两个可表示数之间的最小间隔。
* Number.MAX_SAFE_INTEGER: js 中最大的安全整数，2^53 - 1, 
* Number.MIN_SAFE_INTEGER: js 中最小的安全整数，-(2^53 - 1)
* Number.MAX_VALUE: 能表示的最大正数，最小负数： -Number.MAX_VALUE
* Number.MIN_VALUE: 能表示的最小正数，即最接近0的正数，最大的负数： -Number.MIN_VALUE
* Number.POSITIVE_INFINITY: 正无穷大值，在溢出的时候，返回该值
* Number.NEGATIVE_INFINITY: 负无穷大值，在溢出的时候，返回该值
```js
Number.POSITIVE_INFINITY === Infinity;  // true
Number.NEGATIVE_INFINITY === Infinity;  // false
-Number.NEGATIVE_INFINITY === Infinity; // true
```

# Number 类型的字面值的方法
除了 toString 和 valueOf，Number 类型的字面值还有如下方法：
1. toExponential(): 字符串，返回科学计数法表示的字符串
2. toFixed(num): 字符串，返回固定小数位数的字符串。
3. toPrecision(num)：字符串，保证整数位数和小数位数的和为 num， 如果不能满足要求，则用科学计数法表示。

### Number.NaN (等价于全局的 NaN )
NaN 是一个全局对象的属性。NaN 属性的初始值就是 NaN，和 Number.NaN 的值一样。 
NaN 属性是一个不可配置（non-configurable），不可写（non-writable）的属性。
NaN 产生的途径：
1. 数学计算失败时会返回 NaN，比如 0/0，Math.sqrt(-1), (其他除数为0的情况，会得到 Infinity )
2. 尝试将一个字符串解析成数字但失败了, 比如 Number('a'), parseInt("blabla") 等。
3. 任何与 NaN 做运算的结果都是 NaN
只有 NaN === NaN 为 false，有且只有 NaN 一个!!!
注意： typeof NaN === 'number'
```js
NaN === NaN;        // false
Number.NaN === NaN; // false
isNaN(NaN);         // true
isNaN(Number.NaN);  // true
function valueIsNaN(v) { return v !== v; }
valueIsNaN(1);          // false
valueIsNaN(NaN);        // true
valueIsNaN(Number.NaN); // true
```

## Number 的全局静态函数
* Number.isInteger(): 确定传递的值类型是“number”，且是整数。
* Number.isSafeInteger(): 确定传递的值是否为安全整数 ( -(2^53 - 1) 至 2^53 - 1之间)。
类似于 1.0000 之类的数是 integer。
```js
Number.isInteger(1.0000);     // true
```
* Number.isFinite(): 如果参数是 NaN，正无穷大或者负无穷大，会返回false，其他返回 true。
* Number.isNaN(): 它和全局的 isNaN 的区别就是，没有自动转 number 的步骤。
```js
// 其他的 Number 静态函数和全局函数没有关系
Number.isNaN === isNaN;           // false
Number.isFinite == isFinite;      // false
```

### isNaN vs Number.isNaN, isFinite vs Number.isFinite
Number下面的方法会更严格，Number 下面的方法会默认输入参数已经是 number 类型。
而且全局的 isNaN, isFinite 方法，会默认把参数转换为 number 再进行判断。
```js
isNaN('a');         // true
Number.isNaN('a');  // false
Number.isNaN(NaN);  // true, 只有输入参数为 NaN 时才会为 true

isNaN('    ');    // false
// 等价于
Number.isNaN(Number('   '));    // false, Number('    ') 为 0

isFinite('123');          // true
Number.isFinite('123');   // false
```

* Number.parseInt(str, radix = 10): 等价于全局的 parseInt()
* Number.parseFloat(value): 等价于全局 parseFloat()
```js
Number.parseInt === parseInt;       // true
Number.parseFloat === parseFloat;   // true
```
### parseFloat(value)
### parseInt(str, radix)

# parseFloat (string)
解析规则：
1. 开头和结尾的空白符允许存在，会被忽略.
2. 如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数
(parseInt中可能遇到十六进制，ABCDEF等，在满足条件下，parseInt中属于有效字符)
3. 如果参数字符串(有效的)第一个字符不能被解析成为数字,则parseFloat返回NaN.
4. "(-)Infinity"开头的的字符串会被解析为(-)Infinity.


# parseInt （string, radix）
radix: 一个介于2和36之间的整数，表示上述字符串的基数。
比如参数"10"表示使用我们通常使用的十进制数值系统.
当未指定基数时，不同的实现会产生不同的结果，通常将值默认为10.
同上，如果第一个有效字符不能被转换成数字，parseInt返回NaN

## 不同于parseFloat:
一些字符串中可能包含e字符（例如6.022e23），使用parseInt去截取包含e字符数值部分会造成难以预料的结果。例如：
```js
parseInt("6.022e23", 10);        // 返回 6
parseInt(6.022e2, 10);          // 返回 602
```

在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：
1. 如果字符串 string 以"0x"或者"0X"开头, 则基数是16 (16进制).
2. 如果字符串 string 以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。
3. 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。

说明：
1. parseInt不应该用作 Math.floor()的替代品
2. 将整型数值以特定基数转换成它的字符串值可以使用 intValue.toString(radix).

```js
parseInt(4.7, 10);      // 返回 4
parseInt(4.7 * 1e22, 10); // 非常大的数值变成 4
parseInt(0.00000000000434, 10); // 非常小的数值变成 4
```

# isFnite()
```js
isFinite(Infinity);  // false
isFinite(NaN);       // false
isFinite(-Infinity); // false

isFinite(0);         // true
isFinite(2e64);      // true, 在更强壮的Number.isFinite(null)中将会得到false

isFinite("0");       // true, 在更强壮的Number.isFinite('0')中将会得到false
```





