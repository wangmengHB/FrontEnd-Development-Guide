# Symbol
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol

Symbol 是字面值类型，匿名唯一值，symbol值可以作为对象属性的标识符，这是symbol数据的主要用法。
在其他的编程语言中，symbol 类型可能被叫做 atom。
`Symbol([description])`中的 description 是可选的，仅为调试设计。
Symbol 不支持 new 操作。String/Number/Boolean 之所以支持 new 操作，是因为历史原因。
可以通过一下方法来获得 new Symbol 的效果:
```js
var sym = Symbol("foo");
typeof sym;     // "symbol"
var symObj = Object(sym);
typeof symObj;  // "object"
```

# Symbol 静态方法
使用 Symbol() 函数的语法，不会在你的整个代码库中创建一个可用的全局symbol类型。
要创建跨文件可用的symbol，甚至跨域（每个都有它自己的全局作用域）, 使用 Symbol.for() 方法和  Symbol.keyFor() 方法从全局的symbol注册表设置和取得symbol。
* Symbol.for(key)
使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。
* Symbol.keyFor(sym)
从全局symbol注册表中，为给定的symbol检索一个共享的symbol key。
这里的key不是js中的任何类型，在js中的表现是 undefined。可以通过一个 tricky 让 key 为字符串。
```js
var s = Symbol.for('tokenString'); // 使用 tokenString 作为key创建了一个 symbol s
var key = Symbol.keyFor(s);       // 获取 s 的key， 它为 'tokenString'
```

## 全局Symbol常量
## array-like 相关 
* Symbol.iterator: 用于数组（或 array-like）对象的属性, 它是该数组对象的一个函数，执行结果返回数组的迭代器。
## 字符串相关
借助 Symbol.search/replace/split/match, 可以使得 string 的这些方法输入参数不一定是 字符串或者正则表达式，也可以是对象。
* Symbol.search: 表示对象的一个方法，返回字符串匹配正则的index。这个函数会被 String.prototype.search() 方法调用。
```js
class Search1 {
  constructor(value) {
    this.value = value;
  }
  [Symbol.search](string) {
    return string.indexOf(this.value);
  }
}

console.log('foobar'.search(new Search1('bar')));
// expected output: 3
```
* Symbol.replace, Symbol.split, Symbol.match 同上
## 其他 symbols
* Symbol.hasInstance:
对应 instanceof， 
* Symbol.isConcatSpreadable: 
* Symbol.unscopables:
* Symbol.species:
* Symbol.toPrimitive:
* Symbol.toStringTag:


# Symbol 类型的方法
1. Symbol.prototype.toString()
返回包含Symbol描述符的字符串。
2. Symbol.prototype.valueOf()
返回Symbol对象（如果是对象，Object(sym)）的初始值。
3. `Symbol.prototype[@@toPrimitive]`
返回 Symbol 对象的初始值，相当于与 valueOf。
```js
var s = Symbol();
s[Symbol.toPrimitive]() === s;  // true
```

# Symbol 的特性
1. 在 for in 迭代中，symbol 不可枚举。可以使用 Object.getOwnPropertySymbols() 获取。
2. JSON.stringify, 会忽略 Symbols 属性。
3. Symbol包装器对象可以作为对象的键
```js
var sym = Symbol();
var obj = {[sym]: 1};
// or var obj = {[Object(sym)]: 1};
obj[sym];             // 1
obj[Object(sym)];     // 1
```


# 注： Symbol 在IE下完全不支持，并且没有 polyfill。