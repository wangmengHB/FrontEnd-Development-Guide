# let 和 const

在之前的笔试题中,使用let替换掉所有的var,基本上问题都解决了.




### var和function的变量提升效应
```js
// 例子1:
function(input) {

    alert(input);

    var input = 1000;
}

// 例子2:
function(input) {

    alert(input);

    var input = 1000;
    
    function input() {}
}

```

任何时候使用变量必需要声明,否则会成为全局变量！！！

变量的提升效应:
1. 变量会提升到作用域的最开始的地方(赋值操作不会提前),这个作用域还包括的函数的输入参数
2. function 声明的变量的提升等级是第一位的,并且同时赋值, 它可以在使用效果上把输入参数的变量给屏蔽掉(往往是非预期的).

上面的代码可以翻译成如下:
```js
function(var input = `输入`) {   // 这是执行的一句
    alert(input);
    input = 1000;
}

function(var input = `输入`) {  
    input = function() {};  // 提升到函数体最前部.
    ...

    alert(input)
    input = 1000;
} 

```

### 第一种常见的bug
当函数层数增多和代码工程量变大的时候的时候,经常会非主观意愿下犯一些类似的错误.

```js
function run() {
    var t = new Date();
    setTimeout(function() {
        console.log(t);

        var t = new Date();
        console.log(t);
    }, 1000);
}

```
bug fix:

```js
function run() {
    var t = new Date();
    setTimeout(function(t) {
        console.log(t);

        var t = new Date();
        console.log(t);
    }.bind(null, t), 1000);
}

```
细节问题: 最内层函数中的t实际上是另外一个t,给外层函数中的t不是一个变量.
可以这样理解:
```js
function(var t = `外层的t`) {
    console.log(t);
    t = new Date();
    console.log(t);
}

```

### 第二种常见的bug
几乎每一本javascript书中都会提到,这里换一种用法,使用定义函数,而不是setTimeout.

```js
var obj = [];
for (var i = 1; i < 10; i++) {
    obj['fun' + i] = function() {
        console.log(i);
    }
}
obj[fun5]()

```


## ES6 的解决方案: let
1. 同一个变量不能重复声明,
2. 变量声明之前,不能使用变量,相当于取消了自动提升效应.
3. 在循环体中声明的变量,作用域只在循环体中的{},循环体的{}属于块级别作用域.
4. 没有全局变量

### 第一种bug的解法
使用let全部替换var, 会被IDE工具直接检测或者运行时直接抛异常,提醒开发者,有三个选择:1. 重新取一个名字,2. 去掉let,修改外部变量,3. 放弃使用外部变量,内部的let产生一个同名字的局部变量.

### 第二种bug的解法
使用let全部替换var,功能就是作者想要的了.
原因是循环体中的let是一个块级作用域.

### 例子:
```js
let abc = 80;
if (true) {
    let abc = 1000;
    console.log(abc);
}
console.log(abc);
```



## const 和 let 的区别

const只是针对字面值(primitive value)的常量,对于一个对象类型(除了字面值以外都是对象类型)来说, 没有常量的概念,变量只是代表对象一个引用.

对于对象类型的变量,使用const和let是没有区别的. 更多的作用是表达作者意图.