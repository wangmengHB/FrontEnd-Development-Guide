# JS的模块化

ES6最重要的贡献就是js的模块化, 从根源上清楚了全局变量. 
如果需要创建全局变量，只能显示地在window(对于前端主线程全局对象是window, Web Worker中的全局对象是global， 对于nodejs全局对象是process)上注入全局变量.

每一个文件就是一个module.

### 每个文件(module)对外有依赖，就使用import:

```js
// 可以是引入一个对象或变量
import React, {Component} from 'react';

// 也可以引入一个css/less/sass文件
import './xxx.scss'

// 也可以引入一个资源
import BIRD_PNG './xxx.png';
let img = new Image();
img.src = BIRD_PNG;

```

这里有一个引入路径的小问题，如果from后面内容完全不带路径，表示是从node_modules中引入.
自己定义的module，需要在带一个相对路径，即使在同一目录下，也需要使用'./'.

这有点类似于c++中的，#include <std> 和 include 'xxx.h'.





### 每个文件(module)对外的接口，直接使用export:

```js
// 对外的接口一个类
export default class A {};

// 另外的文件中引用 class A：
import A from './A.js';
import * as A from './A.js';
```

```js
// 对外的接口是一个函数
export default function B () {}


```


```js
// 对外的接口是一个对象
export default {
    getIn: () => {},
    getOut: () => {},
    ...
}
```


```js
// 对外的接口是一堆常量和函数
export const MAX_COUNT = 50;
export const TITLE = "dialog title";
export const createGUID = () => {};
...


```



想起了曾经使用angular1的痛苦场景:

```js
(function(){
    var module1 = angular.module('module', []);
    controller.$injector = ['module2', 'module3', ...];
    module.controller('xxxController', controller);
    function controller($scope, module2, module3, ...) {

    };
})()

```