# Promise

Promise的概念很早就有了，它是javascript处理异步流程的规范，早在ES6出来之前，多个第三库(angular, jquery等等)都对Promise做出过实现，
jQeury.deferred就是其中的一种.


## 没有Promise的异步流程的痛点

### 异步多层嵌套是个灾难.

以下是三个异步函数：

```js

var asyncA = function(option) {
    setTimeout(function() {
        console.log('A function success!');
        option.callback()
    }, Math.random() * 5 * 1000);
}

var asyncB = function(option) {
    setTimeout(function() {
        console.log('B function success!');
        option.callback();
    }, Math.random() * 5 * 1000);
}

var asyncC = function(option) {
    setTimeout(function() {
        console.log('C function success!');
        option.callback();
    }, Math.random() * 5 * 1000);
}

```
现在要求，A执行完了，执行B，B执行完了执行C：

```js
// 只能写成这样了:

asyncA({
    callback: function() {
        asyncB({
            callback: function() {
                asyncC({
                    callback: function() {
                        console.log('done!');
                    }
                })
            }
        });
    }
})


```
以上函数的问题：
1. 嵌套层数太深，异步过程被耦合在一起.
2. 闭包层数过多，内存浪费，最后一个异步过程可以访问第一次异步的数据.
3. 代码的可阅读性太差.


### Promise的异步处理过程

```js
let asyncA = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('A function success');
            resolve('A function success');
        }, Math.random() * 5 * 1000)
    })
}

let asyncB = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('B function success');
            resolve('B function success');
        }, Math.random() * 5 * 1000)
    })
}

let asyncC = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('C function success');
            resolve('C function success');
        }, Math.random() * 5 * 1000)
    })
}

```


```js

asyncA().then(() => {
    return asyncB();
}).then(() => {
    return asyncC();
}).then(() => {
    console.log('All async done!!');
})

```

可以看出整个异步的过程实际上是被拉平了，从多层的嵌套结构变成了有且只有一层的链式写法, 最后一个函数也不能访问第一个函数的闭包空间, 节省内存空间.
整个数据的传递是通过resolve的参数，第一个异步的resolve(data), 可以作为第二个异步函数的输入参数.


### Promise.All 和 Promise.race， Promise.resolve()

除了这些以外，Promise提供整个异步流程的解决方案.

case 1. 不要求 A，B, C 的执行顺序，只要求A，B，C都执行完了.

```js

Promise.all([
    asyncA(),
    asyncB(),
    asyncC()
]).then((data1, data2, data3) => {
    console.log('all done!');
})

```



case 2. 要求只处理 A, B, C 中异步执行最快的那个（比如使用多个账号抢一个车次的火车票）
```js
Promise.race([
    asyncA(), 
    asyncB(), 
    asyncC()
]).then((data) => {
    console.log('fastest is done! others are dropped!')
})

```


#### 深入剖析:自己动手实现一个Promise

```js

class MockPromise {
    static all([...p]) {
       // ...
    }

    static race([...p]) {
      //  ...
    }

    constructor(fn) {
        this.__fn = fn;
    }

    then(onResolve, onReject) {
        return this.__fn(onResolve, onReject);
        
    }
}

let asyncD = () => {
    return new MockPromise((resolve, reject) => {
        setTimeout(() => {
            console.log('A function success');
            return resolve('A function success');
        }, Math.random() * 5 * 1000)
    })
}



```

 

