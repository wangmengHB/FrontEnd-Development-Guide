# promise的基本特性
1. Promise本质是一个状态机.每个promise只能是3种状态中的一种：pending, resolved 或 rejected.状态转变只能是 pending -> resolved 或者 pending -> rejected.状态转变不可逆。
2. 每个promise都有一个then(catch)方法. promise.then()方法必须返回一个新的promise.
无论传入then的函数本身是否返回promise，then()最终返回值都被封装成一个新的promise对象，进而可以无限then链式调用.
4. 值穿透
每个promise对象都有一个属性，用于存储resolve或者reject完成后的值.

# Promise的数据结构设计
一个基本的Promise的结构如下：
```js
const PENDING = 0
const RESOLVED = 1
const REJECTED = 2

function INTERNAL() {}

class Promise {
    constructor (resolver) {
        this.state = PENDING
        this.value = void 0
        this.queue = []
        if (resolver !== INTERNAL) {
            safelyResolve(this, resolver)
        }
    }
    then () {}
    catch () {}
    finally () {}
    // static methods
    static resolve () {}
    static reject () {}
    static all () {}
    static race () {}
}
```
每个promise实例中至少应该有三个属性：
1. state：标记状态，并且状态变化不可逆.
2. value: 存储返回值，当state为RESOLVED时，它为传递给下一个then的结果. 当state为REJECTED时，它存储错误值.
3. queue: promise内部的回调队列.
queue是promise内部的数据结构，不必让外部知道它的存在，可以将它的属性设置为enumerable为false.

## safelyResolveThen
```js
function safelyResolveThen(self, then) {
    let called = false;
    try {
        then(function(value) {
            if (called) {
                return
            }
            called = true
            doResolve(self, value)
        }, function(error) {
            if (called) {
                return
            }
            called = true
            doReject(self, error)
        })
    } catch (error) {
        if (called) {
            return
        }
        called = true
        doReject(self, error)
    }
}

```
这里之所以加上called, 是为了保证状态变化的不可逆.
例如
```js
let p = new Promise((resolve, reject) => {
    reject()
    resolve()
})
```
在这个例子里，reject先执行，所以promise的状态会变为REJECTED, 而不论后面是否存在resolve().


## doResolve(self, value)
```js
function doResolve(self, value) {
    try {
        let then = getThen(value)
        if (then) {
            safelyResolveThen(self, then)
        } else {
            self.state = RESOLVED
            self.value = value
            self.queue.forEach(function(queueItem) {
                queueItem.callResolve(value)
            })
            return self
        }
    } catch (error) {
        return doReject(self, error)
    }
}

function doReject (self, error) {
    self.state = REJECTED
    self.value = error
    self.queue.forEach(function(queueItem) {
        queueItem.callReject(error)
    })
    return self
}

function getThen (obj) {
    let then = obj && obj.then
    if ((obj && (isObject(obj) || isFunction(obj))) && 
        isFunction(then)
    ) {
        return function applyThen() {
            then.apply(obj, arguments)
        }
    }
} 

```

## Promise.prototype.then
```js
class Promise {
    ...
    then (onResolve, onReject) {
        if (!isFunction(onResolve) && this.state === RESOLVED ||
            !isFunction(onReject) && this.state === REJECTED
        ) {
            return this
        }
        let promise = new Promise(INTERNAL)
        if (this.state !== PENDING) {
            let resolver = this.state === RESOLVED? onResolve: onReject
            unwrap(promise, resolver, this.value)
        } else {
            this.queue.push(new QueueItem(promise, onResolve, onReject))
        }
        return promise
    }
}

function unwrap (promise, func, value) {
    setTimeout(() => {
        let returnValue
        try {
            returnValue = func(value)
        } catch (error) {
            return doReject(promise, error)
        }
        if (returnValue === promise) {
            doReject(promise, new TypeError('Cannot resolve promise itself.'))
        } else {
            doResolve(promise, returnValue)
        }
    }, 0)
}

class QueueItem {
    constructor (promise, onResolve, onReject) {
        this.promise = promise
        this.onResolve = onResolve
        this.onReject = onReject
    }

    callResolve (value) {
        if (isFunction(this.onResolve)) {
            unwrap(this.promise, this.onResolve, value)
        } else {
            doResolve(this.promise, value)
        }
    }

    callReject (error) {
        if (isFunction(this.onReject)) {
            unwrap(this.promise, this.onReject, value)
        } else {
            doReject(this.promise, error)
        }
    }
}
```




