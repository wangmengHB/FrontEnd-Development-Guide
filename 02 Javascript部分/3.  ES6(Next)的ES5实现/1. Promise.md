# promise的基本特性
1. Promise 本质是一个状态机.每个promise只能是3种状态中的一种：pending, resolved 或 rejected.状态转变只能是 pending -> resolved 或者 pending -> rejected.状态转变不可逆。
2. 每个promise都有一个then(catch)方法. promise.then()方法必须返回一个新的promise.
无论传入then的函数本身是否返回promise，then()最终返回值都被封装成一个新的promise对象，进而可以无限then链式调用.
4. 值穿透
每个promise对象都有一个属性，用于存储promise完成后的值.

# Promise的数据结构设计
一个基本的Promise的结构如下：
```js
const PENDING = 0
const FULLFILLED = 1
const REJECTED = 2

class Promise {
    constructor (resolver) {
        this.state = PENDING
        this.value = void 0
        this.queue = []
        safelyResolve(this, resolver)
        ...      
    }
    then () {}
    catch () {}
    // static methods
    static resolve () {}
    static reject () {}
    static all () {}
    static race () {}
}
```
每个promise实例中至少应该有三个属性：
1. state：标记状态，并且状态变化不可逆.
2. value: 存储返回值，当state为FUlLFILLED时，它为传递给下一个then的结果. 当state为rejected时，它存储错误值.
3. queue: promise内部的回调队列.

```js
function safelyResolveThen(self, then) {
    let called = false;
    try {
        then(function(value) {
            if (called) {
                return
            }
            called = true
            doResolve(self, value)
        }, function(error) {
            if (called) {
                return
            }
            called = true
            doReject(self, error)
        })
    } catch (error) {
        if (called) {
            return
        }
        called = true
        doReject(self, error)
    }
}

```

```js
function doResolve(self, value) {
    try {
        let then = getThen(value)
        let isPromise = value instanceof Promise
        if (isPromise) {

        } else {
            self.state = FULLFILLED
            self.value = value
            self.queue.forEach(function(queueItem) {
                queueItem.callFullfilled(value)
            })
            return self
        }
        if (then) {
            safelyResolveThen(self, then)
        } else {
            self.state = FULLFILLED
            self.value = value
            self.queue.forEach(function(queueItem) {
                queueItem.callFullfilled(value)
            })
            return self
        }
    } catch (error) {
        return doReject(self, error)
    }
}

function doReject (self, error) {
    self.state = REJECTED
    self.value = error
    self.queue.forEach(function(queueItem) {
        queueItem.callRejected(error)
    })
    return self
}

function getThen (obj) {
    let then = obj && obj.then

} 

```


