# promise的基本特性
1. Promise 本质是一个状态机.
每个 promise 只能是 3 种状态中的一种：pending、fulfilled 或 rejected.
状态转变只能是 pending -> fulfilled 或者 pending -> rejected。状态转变不可逆。
2. then 方法可以被同一个 promise 调用多次。
3. then 方法必须返回一个 promise。
规范里没有明确说明返回一个新的 promise 还是复用老的 promise（即 return this），大多数实现都是返回一个新的 promise，而且复用老的 promise 可能改变内部状态，这与规范也是相违背的。
4. 值穿透

# Promise的数据结构设计
一个基本的Promise的结构如下：
```js
const PENDING = 0
const FULLFILLED = 1
const REJECTED = 2

class Promise {
    constructor (resolver) {
        this.state = PENDING
        this.value = void 0
        this.queue = []
        safelyResolve(this, resolver)
        ...      
    }
    then () {}
    catch () {}
    // static methods
    static resolve () {}
    static reject () {}
    static all () {}
    static race () {}
}
```
每个promise实例中至少应该有三个属性：
1. state：标记状态，并且状态变化不可逆.
2. value: 存储返回值，当state为FUlLFILLED时，它为传递给下一个then的结果. 当state为rejected时，它存储错误值.
3. queue: promise内部的回调队列.

```js
function safelyResolveThen(self, then) {
    let called = false;
    try {
        then(function(value) {
            if (called) {
                return
            }
            called = true
            doResolve(self, value)
        }, function(error) {
            if (called) {
                return
            }
            called = true
            doReject(self, error)
        })
    } catch (error) {
        if (called) {
            return
        }
        called = true
        doReject(self, error)
    }
}

```

```js
function doResolve(self, value) {
    try {
        let then = getThen(value)
        let isPromise = value instanceof Promise
        if (isPromise) {

        } else {
            self.state = FULLFILLED
            self.value = value
            self.queue.forEach(function(queueItem) {
                queueItem.callFullfilled(value)
            })
            return self
        }
        if (then) {
            safelyResolveThen(self, then)
        } else {
            self.state = FULLFILLED
            self.value = value
            self.queue.forEach(function(queueItem) {
                queueItem.callFullfilled(value)
            })
            return self
        }
    } catch (error) {
        return doReject(self, error)
    }
}

function doReject (self, error) {
    self.state = REJECTED
    self.value = error
    self.queue.forEach(function(queueItem) {
        queueItem.callRejected(error)
    })
    return self
}

function getThen (obj) {
    let then = obj && obj.then

} 

```


