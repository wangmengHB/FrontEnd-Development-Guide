# 类型判断
在各种js开源库中，通常都会找到一大堆的util函数用于判断原生数据类型. 通常情况下需要结合typeof和Object.prototype.toString联合使用来判断原生类型.

在总体来说：
typeof: 是用来判断字面值类型. 
Object.prototype.toString: 是用来判断对象类型.
注意：字面值不能使用new!!!
```js
'stringA' != new String('stringA')
// new String 生成的String对象，不是String字面值.
new String('stringA') != new String('stringA')
```

# typeof
## typeof的值只有7个：
1. undefined, 
2. object, 
3. number, 
4. boolean, 
5. function, 
6. string, 
7. symbol

## 注意 
1. 不存在array
2. 除了函数以外，一切引用类型都为object.

例子：
```js
typeof undefined === 'undefined'
typeof null === 'object'
typeof [] === 'object'
typeof /^regex$/ === 'object'
typeof NaN === 'number'
typeof Infinity === 'number'
```

# Object.prototype.toString() 和 String()
除了字面值类型以外，其他所有类型都是对象，其原型链最终都可以追溯到Object.prototype.
```js
Function.prototype.__proto__ === Object.prototype
Array.prototype.__proto__ === Object.prototype
Date.prototype.__proto__ === Object.prototype
RegExp.prototype.__proto__ === Object.prototype
Error.prototype.__proto__ === Object.prototype

// 字面值对象, 字面值不能使用new！！！
Number.prototype.__proto__ === Object.prototype
String.prototype.__proto__ === Object.prototype
Boolean.prototype.__proto__ === Object.prototype
Symbol.prototype.__proto__ === Object.prototype
```
但是每个子类的prototype.toString以及静态方法toString都自己重写了：
```js
Function.toString != Function.prototype.toString != Object.prototype.toString
Array.toString != Array.prototype.toString != Object.prototype.toString
Date.toString != Date.prototype.toString != Object.prototype.toString
RegExp.toString != RegExp.prototype.toString != Object.prototype.toString
Error.toString != Error.prototype.toString != Object.prototype.toString

// 字面值对象, 字面值不能使用new！！！
Number.toString != Number.prototype.toString != Object.prototype.toString
String.toString != String.prototype.toString != Object.prototype.toString
Boolean.toString != Boolean.prototype.toString != Object.prototype.toString
Symbol.toString != Symbol.prototype.toString != Object.prototype.toString
Object.toString != Object.prototype.toString

// 目前发现的相同只有以下两个是相同的：
Object.toString === Function.prototype.toString
```
综上所述, 使用toString来判断原生数据类型的方法只能使用Object.prototype.toString.
注意：只能获取原生类型的类型.


```js
let _toString = Object.prototype.toString
class A {
}
let a = new A
_toString.call(a)            // [object Object]
Object.getPrototypeOf(b).constructor === A

_toString.call(new Date);    // [object Date]
_toString.call(new String);  // [object String]
_toString.call(Math);        // [object Math]

// Since JavaScript 1.8.5
_toString.call(undefined);   // [object Undefined]
_toString.call(null);        // [object Null]
```








# valueOf()




# instanceof



