# class
在构造函数里访问 this 之前，一定要调用 super()。
1. public，private，protected，readonly 修饰符
在ts中，成员默认都是 public.
protected 成员在派生类中仍然可以访问。
构造函数被标记为 protected 表示，这个类不能被实例化，但是可以被继承。
readonly 修饰符，只读属性只能在声明时或构造函数里被初始化
```ts
class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
```
构造函数参数属性，在构造函数中直接申明参数为 public，private，protected 即是创建一个同名属性。
2. 存取器 set get
3. static
4. 抽象类 abstract
抽象类作为其他派生类的基类使用。
```ts
abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log('Department name: ' + this.name);
    }

    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
```

# 函数
默认参数的使用方法和ES6中一致。
可选参数必需在必选参数的后面。
支持函数重载。

# 泛型


