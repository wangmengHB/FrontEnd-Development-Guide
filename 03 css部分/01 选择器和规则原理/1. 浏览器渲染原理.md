# DOM是如何渲染的？
任何一个页面是由两个部分组成：DOM 和 css. 
DOM和css之间没有耦合，彼此独立，但它们同时决定了页面该渲染成什么样子.
DOM：文档树形结构.
css: css是由两部分组成:
1. 选择器，选择器中包含一系列规则的集合
2. 规则，比如，color：red； 就是一条规则.

对于DOM的部分，渲染元素的顺序是：
1. 从上到下
2. 从父到子，每渲染完一层都执行一次reflow重新计算布局.
比如一个元素有3层:
1. 首先渲染第1层元素，计算第1层元素的布局，
2. 渲染第2层元素，计算第2层元素的布局，并且触发reflow，第1层元素重新计算布局.
3. 渲染第3层元素，计算第3层元素的布局，并且触发第2层的reflow，第2层元素重新计算布局，触发第1层的reflow

减少不必要的DOM层级会减少reflow的次数.

对于css部分：针对一个具体的元素，该如何渲染：
1. 跟元素在DOM结构中的位置和元素自身的属性，找到该元素所有匹配的选择器
2. 选择器按照优先级权限排序，（元素内联样式优先于css选择器)
3. 按优先级从高到低，依次应用规则，当同一条规则在后面的选择器中也出现时，直接跳过.
4. 决定好元素的所有css规则以后，开始执行渲染. 
(对于同一种规则，元素只可能渲染成一种规则值，比如一个元素不可能同时显示成绿色，又显示成红色)

以上是最基本最简单的渲染流程, 实际上浏览器渲染的DOM的过程要远比这个复杂.
比如，当一个元素的规则中存在定位规则时，那么该元素的渲染还依赖于离它最近的定位元素的位置.



https://kb.cnblogs.com/page/129756/
# 渲染树的构建
Webkit的RenderObject基类
```c++
class RenderObject {
    virtual void layout();          // reflow
    virtual void paint(PaintInfo);
    virtual void rect repaintRect();
    Node* node;                     //the DOM node
    RenderStyle* style;             // the computed style
    RenderLayer* containgLayer;     //the containing z-index layer
}
```
# 渲染树和Dom树的关系
1. 渲染对象和Dom元素相对应，但这种对应关系不是一对一的:
不可见的Dom元素不会被插入渲染树.
还有一些Dom元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
例如，当文本因为宽度不够而折行时，新行将作为额外的渲染元素被添加。
另一个多个渲染对象的例子是不规范的html，
根据css规范，一个行内元素只能仅包含行内元素或仅包含块状元素，
在存在混合内容时，将会创建匿名的块状渲染对象包裹住行内元素.
2. 一些渲染对象和所对应的Dom节点不在树上相同的位置，
例如，浮动和绝对定位的元素在文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置

Webkit中，计算样式并生成渲染对象的过程称为attachment，每个Dom节点有一个attach方法.
attachment的过程是同步的，调用新节点的attach方法将节点插入到Dom树中。

处理html和body标签将构建渲染树的根，这个根渲染对象对应被css规范称为containing block的元素——包含了其他所有块元素的顶级块元素。
它的大小就是viewport——浏览器窗口的显示区域，Firefox称它为viewPortFrame，webkit称为RenderView，这个就是文档所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建.

# style computation
1. 样式数据是非常大的结构，保存大量的样式属性会带来内存问题.
2. 如果不优化，找到每个元素匹配的规则会导致性能问题, 为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量. 
例如： div div div div {} // 三个div的后代div
3. 应用规则涉及非常复杂的级联, 它们定义了规则的层次.











