# DOM是如何渲染的？
任何一个页面是由两个部分组成：DOM 和 css. 
DOM和css之间没有耦合，彼此独立，但它们同时决定了页面该渲染成什么样子.
DOM：文档树形结构.
css: css是由两部分组成:
1. 选择器，选择器中包含一系列规则的集合
2. 规则，比如，color：red； 就是一条规则.

对于DOM的部分，渲染元素的顺序是：
1. 从上到下
2. 从父到子，每渲染完一层都执行一次reflow重新计算布局.
比如一个元素有3层:
1. 首先渲染第1层元素，计算第1层元素的布局，
2. 渲染第2层元素，计算第2层元素的布局，并且触发reflow，第1层元素重新计算布局.
3. 渲染第3层元素，计算第3层元素的布局，并且触发第2层的reflow，第2层元素重新计算布局，触发第1层的reflow

减少不必要的DOM层级会减少reflow的次数.


对于css部分：针对一个具体的元素，该如何渲染：
1. 跟元素在DOM结构中的位置和元素自身的属性，找到该元素所有匹配的选择器
2. 选择器按照优先级权限排序，（元素内联样式优先于css选择器)
3. 按优先级从高到低，依次应用规则，当同一条规则在后面的选择器中也出现时，直接跳过.
4. 决定好元素的所有css规则以后，开始执行渲染. 
(对于同一种规则，元素只可能渲染成一种规则值，比如一个元素不可能同时显示成绿色，又显示成红色)

以上是最基本最简单的渲染流程, 实际上浏览器渲染的DOM的过程要远比这个复杂.
比如，当一个元素的规则中存在定位规则时，那么该元素的渲染还依赖于离它最近的定位元素的位置.

# css选择器
css选择器中有两条默认的规则：
1. 在排在整体css文档下面的选择器和规则, 在同样优先级权重下，会胜出.
可以理解为：后来的更重要的.
2. 在文档流中从父到子选择，从上到下选择，这个方向是不可逆的.
可以理解为：下面的元素不能决定上面的元素样式，子元素不能决定父元素的样式，但只会影响父元素的尺寸.
 

## combinator
1. 不带空格：表示两种条件同时满足
2. ,: 逗号表示两个选择器共用一套规则
3. 空格：表示子元素
4. >： 表示直接子元素
5. +： 临近的直接兄弟元素
6. ~： 后面的兄弟元素



# 选择器优先级（确切的说，应该是该选择器下每条规则对应的优先级权重）
