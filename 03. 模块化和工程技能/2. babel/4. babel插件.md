# Babel插件
https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md
https://shuheikagawa.com/blog/2015/09/13/lets-create-a-babel-plugin/

插件是一个接收当前babel对象作为参数的function, 函数需要返回一个 visitor 对象。
每个visitor函数中接收两个参数：path, state. 
```js
export default function(babel) {
  return {
    visitor: {

    }
  }
}
```
在实际使用中，经常只使用到 babel.types, 所以更常见的形式如下：
```js
export default function({types: t}) {
  return {
    visitor: {
      Identifier(path, state) {},
      ...
    }
  }
}
```
## 转换操作
### path的获取和查找
1. 获取path信息
```js
BinaryExpression(path) {
  // 方法 1. 直接读属性
  path.node.left;
  path.node.right;
  path.node.operator;

  // 方法 2. get
  path.get('left');

  // 判断节点类型
  if (t.isIdentifier(path.node.left, { name: 'n'})) {

  }

  // 等价于
  if (
    path.node.left != null &&
    path.node.left.type === 'Identifier' &&
    path.node.left.name === 'n'
  ) {

  }

}

Program(path) {
  path.get('body.0');
}

```
2. 检查标识符(Identifier)是否被引用 （代码中的变量）
```js
Identifier(path) {
  if (path.isReferencedIdentifier()) {}
  // 或者
  if (t.isReferenced(path.node, path.parent)) {}
}

```
3. 找到特定的父路径
对于每一个父路径调用 callback 并将其 NodePath 当作参数，当 callback 返回真值时，则将其 NodePath 返回。
```js
path.findParent((path) => path.isObjectExpression());
// 如果也需要遍历当前节点
path.find((path) => path.isObjectExpression());
// 查找最近的父函数或程序
path.getFunctionParent();
// 向上遍历语法树，直到找到在列表中的父节点路径
path.getStatementParent();
```
4. 获取同级路径
如果一个路径是在一个 Function/Program 中的列表里，它就有同级节点。
* path.inList: 判断路径是否有同级节点
* path.getSibling(index): 获取同级路径
* path.key: 路径所在容器的索引
* path.container: 路径的容器（包含所有同级节点的数组）
* path.listKey: 容器的key
```js
// 待处理的代码入下：
var a = 1; // pathA, path.key = 0
var b = 2;  // pathB, path.key = 1
var c = 3; // pathC, path.key = 2

// visitor
export default function({types: t}) {
  return {
    visitor: {
      VariableDeclaration(path) {
        // 如果当前的path是pathA
        path.inList; // true
        path.listKey;   // body
        path.key;   // 0
        path.getSibling(0);  // pathA
        path.getSibling(paht.key + 1);  // pathB
        path.container;     // [pathA, pathB, pathC]
      }
    }
  }
}
```
5. 停止遍历, path.skip(), path.stop();
```js
BinaryExpression(path) {
  // 如果插件不需要处理，尽早返回
  if (path.node.operator !== '**') return;
}
```
path.skip(): 跳过遍历当前path的所有子节点。   
path.stop(): 保存状态，并且停止遍历。
### 节点操作
1. 替换节点
```js
// 1.替换单个节点，  n * n   ===>  n ** 2
BinaryExpression(path) {
  if (
    path.node.operator === '*' &&
    path.node.left.name === path.node.right.name
  ) {
    path.replaceWith(
      t.binaryExpression('**', path.node.left, t.numberLiteral(2));
    )
  }
}

// 2.替换多个节点
ReturnStatement(path) {
  path.replaceWithMultiple([
    t.expressionStatement(t.stringLiteral('xxx')),
    t.expressionStatement(t.stringLiteral('yyy')),
    t.expressionStatement(t.stringLiteral('zzz')),
  ]);
}

// 3.使用字符串替换节点
FunctionDeclaration(path) {
  path.replaceWithSourceString(`function add(a, b) { return a + b;}`);
}

```
2. 插入节点
```js


```