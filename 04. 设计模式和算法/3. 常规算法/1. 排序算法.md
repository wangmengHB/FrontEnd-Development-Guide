# 排序算法
对于在应用中的大部分情况来说，我们不需要自己再去实现一个算法，Array.prototype.sort 已经提供了基础排序 API。 
但是为了面试需要，还是需要把基础的排序算法都清楚地掌握。  
https://www.cnblogs.com/eniac12/p/5329396.html


为了后续方便，先准备几个简单的工具函数。

注意： 对于不使用中间变量的交换，对于整数可以使用 异或 或者 加减法 实现。
```js
// 交互数组中的元素
function swap(arr, a, b) {
  let tmp = arr[a];
  arr[a] = arr[b];
  arr[b] = tmp;
}

function comparer(a, b) {
  return a - b;
}

```

# 1. 冒泡算法, 
通过相邻两个的交换法，一次循环能确定最末尾的元素。
算法执行次数固定：, 即 (n + 1) * n / 2.  

```js
function bubleSort(arr, comparer) {
  const len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      if (comparer(arr[j], arr[j + 1]) >  0) {
        swap(arr, j, j + 1);
      }
    }
  }
}
```

# 1.1. 鸡尾酒排序， 冒泡改进版
和冒泡算法的不同，第一轮 找到最末尾， 第二轮 找最首位，依次更替。 
只能减少部分不必要的 swap 行为，但是时间复杂度并没有什么差异。  
```js
function cocktailSort(arr, comparer) {
  const len = arr.length;
  let left = 0, right = len - 1;
  while (left < right) {
    for (let i = left; i < right; i++) {
      if (comparer(arr[i], arr[i + 1]) > 0) {
        swap(arr, i, i + 1);
      }
    }
    right--;
    for (let i = right; i > left; i--) {
      if (compare(arr[i - 1], arr[i]) > 0) {
        swap(arr, i -1, i);
      }
    }
    left++;
  }
}
```

# 2. 选择排序 
1. 在序列中找到 min/max 元素，放置序列的 首/末 位置。 
2. 然后从剩余的序列中继续找 min/max 元素，放置在 首 / 未 位置。
本质上是和冒泡算法一样，只是减少了两两换位操作。  
```js
function selectionSort(arr) {

  
}

```








