# 动态规划算法
每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。    

# 问题 1. 斐波那契数列， 爬楼梯可能性问题  
* 最优子结构    f(10) = f(8) + f(9)
* 边界         f(1) = 1; f(2) = 2;
* 状态转移公式   
f(n) = f(n-1) + f(n-2). 阶段与阶段之间的状态转移方程。 决定了问题的每一个阶段和下一个阶段的关系。  

* 备忘录算法
将计算过的节点缓存起来，不用重复计算。  
```js
function fn(n, map = new Map) {
  if ( n < 1) {
    return 0;
  }
  if ( n === 1) {
    return 1;
  }
  if ( n === 2) {
    return 2;
  }
  if (map.has(n)) {
    return map.get(n)
  } else {
    let value = fn(n - 1, map) + fn(n -2, map);
    map.set(n, value);
    return value;
  }
}
```

* 动态规划算法
先自顶向下，分析出最优子结构。
再自下向顶，只需要保存最少中间结果，不需要每一个节点都缓存。 
```js
function fn(n) {
  if (n < 1) {
    return 0;
  }
  if (n === 1) {
    return 1;
  }
  if (n === 2) {
    return 2;
  }
  let a1 = 1;
  let a2 = 2;
  let temp = 0;
  for (let i = 3; i <= n; i++) {
    temp = a1 + a2;
    a1 = a2;
    a2 = temp;
  }
  return temp;
}
```

# 问题 2. 国王和金矿问题  
有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？


* 方法一：排列组合
每一座金矿都有挖与不挖两种选择，如果有N座金矿，排列组合起来就有2^N种选择。对所有可能性做遍历，排除那些使用工人数超过10的选择，在剩下的选择里找出获得金币数最多的选择。  


最优子结构：
1. 最优选择 = fn（假定1个金矿已挖，剩余4个金矿和剩下的人） + fn(排除这个金矿的剩下4个金矿，全部人)






https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg



https://zhuanlan.zhihu.com/p/49427827
https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html

