
# 分治策略

分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。  

## 分治法适用的情况
1. 问题缩小到一定的程度就可以很容易地解决。  
2. 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。  
3. 子问题的解可以合并为该问题的解。     
4. 各个子问题互相独立，即子问题之间不包含公共的子问题。     


## 分治法的基本步骤

分治法在每一层递归上都有三个步骤：
* step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
* step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
* step3 合并：将各个子问题的解合并为原问题的解。

它的一般的算法设计模式如下：
```
Divide-and-Conquer(P)

1. if |P|≤n0

2. then return(ADHOC(P))

3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk

4. for i←1 to k

5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi

6. T ← MERGE(y1,y2,...,yk) △ 合并子问题

7. return(T)
```

其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解。

## 分治法的复杂性分析

    一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：

 T（n）= k T(n/m)+f(n)

    通过迭代法求得方程的解：

    递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当                  mi≤n<mi+1时，T(mi)≤T(n)<T(mi+1)。 

## 可使用分治法求解的一些经典问题
 （1）二分搜索    
（2）大整数乘法   
 （3）Strassen矩阵乘法    
（4）棋盘覆盖   
（5）合并排序   
（6）快速排序   
（7）线性时间选择   
（8）最接近点对问题   
（9）循环赛日程表   
（10）汉诺塔    

## 依据分治法设计程序时的思维过程
实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。
1、一定是先找到最小问题规模时的求解方法
2、然后考虑随着问题规模增大时的求解方法
3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。



# 贪心算法
对问题求解时，总是做出在当前看来是最好的选择， 也就是说，不从整体上最优考虑，他所做出的仅在某种意义上的局部最优解。  

贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。

所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。


二、贪心算法的基本思路：
    1.建立数学模型来描述问题。
    2.把求解的问题分成若干个子问题。
    3.对每一子问题求解，得到子问题的局部最优解。
    4.把子问题的解局部最优解合成原来解问题的一个解。


三、贪心算法适用的问题
      贪心策略适用的前提是：局部最优策略能导致产生全局最优解。
    实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。

四、贪心算法的实现框架
    从问题的某一初始解出发；
    while （能朝给定总目标前进一步）
    { 
          利用可行的决策，求出可行解的一个解元素；
    }
    由所有解元素组合成问题的一个可行解；
  
五、贪心策略的选择
     因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。
 
六、例题分析
    下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。
    `[背包问题]`有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。
    要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。
    物品 A B C D E F G
    重量 35 30 60 50 40 10 25
    价值 10 40 30 50 35 40 30
    分析：
    目标函数： ∑pi最大
    约束条件是装入的物品总重量不超过背包容量：∑wi<=M( M=150)
    （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？
    （2）每次挑选所占重量最小的物品装入是否能得到最优解？
    （3）每次选取单位重量价值最大的物品，成为解本题的策略。
    值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。
    贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。
    可惜的是，它需要证明后才能真正运用到题目的算法中。
    一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。
    对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：
    （1）贪心策略：选取价值最大者。反例：
    W=30
    物品：A B C
    重量：28 12 12
    价值：30 20 20
    根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。
    （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。
    （3）贪心策略：选取单位重量价值最大的物品。反例：
    W=30
    物品：A B C
    重量：28 20 10
    价值：28 20 10
    根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。


