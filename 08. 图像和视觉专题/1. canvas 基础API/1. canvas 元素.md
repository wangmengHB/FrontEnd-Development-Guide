标准文档：
https://html.spec.whatwg.org/multipage/canvas.html#the-canvas-element


# canvas 
1. canvas 元素属于替换元素, 必须是以` <canvas></canvas> `(不同于`<img/>`) 形式处理，(虽然在React中会处理)。
2. 如果不设置宽度/高度，则默认宽度 300， 高度 150.
3. width/height 和 style 中的 width 和 height 的区别： 
* 属性width/height 表示像素。
* style 中的 width/height 只表示显示视窗。 style 只会影响视觉，不会影响画布内容。


# rendering context: HTMLCanvasElement.getContext( contextType, contextAttributes)
在同一个 canvas 上多次调用此方法（类型相同），返回的是同一个的 context。  
？推论：
1. 可以认为一个 canvas 只存在固定的几种 context。
2. 第一次使用的 getContext 是创建 context, 以后调用的相同类型的 context 只是引用。 
  

## contextType:
1. 2d: 
2. webgl: 
3. webgl2: (实验中)
4. bitmaprenderer: (实验中)

### 2d 的 contextAttributes
alpha: 表示画布是否包含透明度通道。

### webgl 的 contextAttributes
* alpha
* antialiase
* depth: boolean, 表明绘制缓冲区包含一个深度至少为 16 位的缓冲区。  
* stencil: boolean, 表明绘制缓冲区包含一个深度至少为 8 位的模板缓冲区。  
* preserveDrawingBuffer: 如果这个值为 true，缓冲区将不会被清楚，会保存下来，直到被清除或被使用者覆盖。
注意：在绘制完成后的 event loop 中，应该立即导出画布内容，否则导出的内容为空。
* premulipliedAlpha: boolean, 表明排版引擎将假设绘制缓冲区包含预混合 alpha 通道。   
颜色rgb已经预乘以 alpha 值。
* failIfMajorPerformanceCaveat: boolean, 表明在一个系统性能低的环境是否创建该上下文。  
* powerPreference: 指示浏览器在运行 webgl context 时使用相应的 GPU 电源配置。可能值如下：
  * default: 自动选择, 默认值
  * high-performance: 高性能模式
  * low-power: 节能模式


## 问题
1. 已验证：任何对 canvas 的 width 和 height 的写操作会导致 canvas 清空，即使值不会发生变化。 
2. 已验证：任何对 canvas 的 width 和 height 的写操作会导致 context 中的全局属性被重置。 
3. 已验证: 每一次调用同类型的 getContext 获取的还是同一个 contenxt，传入的 contextAttributes 不同，可能会动态改变 context  
alpha: true / false, 只会在第一次画的时候影响画布，仅影响一次。   
```js
var ctx = canvas.getContext('2d', { alpha: true});
var ctx2 = canvas.getContext('2d', { alpha: false});
ctx === ctx2;       // true
drawFace(ctx2);     // 整个画图还是透明的
```
4. 坐标并不是和像素格子一一对应，坐标值可以为小数，imageData 的值只是渲染后的数据值。  
像素格子类似与围棋棋盘，坐标原点就是棋盘的左上角(0, 0). 对于没有完全落在像素格子里的颜色，透明度值会跟格子面积占比成正比。  



## 获取结果 toDataURL, toBlob  
* toDataURL(type, quality)
type: 'image/png'（默认） | 'image/jpeg' | 'image/webp' (仅chrome支持)
quality: 默认 0.92， 0 - 1. 如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。  
图片的分辨率为96dpi。   
如果画布的高度或宽度是0，那么会返回字符串“data:,”。   
如果传入的类型非“image/png”，但是返回的值以“data:image/png”开头，那么该传入的类型是不支持的。   



* toBlob(callback, type, quality)


https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes


# best practice 
When a canvas is interactive, authors should include focusable elements in the element's fallback content corresponding to each focusable part of the canvas, as in the example above.

When rendering focus rings, to ensure that focus rings have the appearance of native focus rings, authors should use the drawFocusIfNeeded() method, passing it the element for which a ring is being drawn. This method only draws the focus ring if the element is focused, so that it can simply be called whenever drawing the element, without checking whether the element is focused or not first.

In addition to drawing focus rings, authors should use the scrollPathIntoView() method when an element in the canvas is focused, to make sure it is visible on the screen (if applicable).

Authors should avoid implementing text editing controls using the canvas element. Doing so has a large number of disadvantages:

Mouse placement of the caret has to be reimplemented.
Keyboard movement of the caret has to be reimplemented (possibly across lines, for multiline text input).
Scrolling of the text control has to be implemented (horizontally for long lines, vertically for multiline input).
Native features such as copy-and-paste have to be reimplemented.
Native features such as spell-checking have to be reimplemented.
Native features such as drag-and-drop have to be reimplemented.
Native features such as page-wide text search have to be reimplemented.
Native features specific to the user, for example custom text services, have to be reimplemented. This is close to impossible since each user might have different services installed, and there is an unbounded set of possible such services.
Bidirectional text editing has to be reimplemented.
For multiline text editing, line wrapping has to be implemented for all relevant languages.
Text selection has to be reimplemented.
Dragging of bidirectional text selections has to be reimplemented.
Platform-native keyboard shortcuts have to be reimplemented.
Platform-native input method editors (IMEs) have to be reimplemented.
Undo and redo functionality has to be reimplemented.
Accessibility features such as magnification following the caret or selection have to be reimplemented.
This is a huge amount of work, and authors are most strongly encouraged to avoid doing any of it by instead using the input element, the textarea element, or the contenteditable attribute.

