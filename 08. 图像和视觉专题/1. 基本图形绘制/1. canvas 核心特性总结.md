# canvas 
标准文档：https://html.spec.whatwg.org/multipage/canvas.html#the-canvas-element  

canvas 上只有三个核心的方法：1. getContext, 2. toDataURL, 3. toBlob. 


## 1. 渲染上下文 rendering context: HTMLCanvasElement.getContext( contextType, contextAttributes)
所有的画布内容都在 context 中产生, 通过 getContext 方法获取这个上下文。     
注意： 一个 canvas 上只能存在一种类型的 context， 第一调用 getContext 时即是创建上下文， 以后调用的相同类型的 getContext 只是返回引用。 非同类型的 getConext 会返回 null。  

* 上下文的类型 contextType 有以下几种:
1. 2d: 
2. webgl: 
3. webgl2: (实验中)
4. bitmaprenderer: (实验中)

### 1.1 2d 的 contextAttributes
alpha: 表示画布是否包含透明度通道。   
alpha: true / false, 只会在第一次画的时候影响画布，仅影响一次。     

### 1.2 webgl 的 contextAttributes
* alpha
* antialiase
* depth: boolean, 表明绘制缓冲区包含一个深度至少为 16 位的缓冲区。  
* stencil: boolean, 表明绘制缓冲区包含一个深度至少为 8 位的模板缓冲区。  
* preserveDrawingBuffer: 如果这个值为 true，缓冲区将不会被清楚，会保存下来，直到被清除或被使用者覆盖。
注意：在绘制完成后的 event loop 中，应该立即导出画布内容，否则导出的内容为空。
* premulipliedAlpha: boolean, 表明排版引擎将假设绘制缓冲区包含预混合 alpha 通道。   
颜色rgb已经预乘以 alpha 值。
* failIfMajorPerformanceCaveat: boolean, 表明在一个系统性能低的环境是否创建该上下文。  
* powerPreference: 指示浏览器在运行 webgl context 时使用相应的 GPU 电源配置。可能值如下：
  * default: 自动选择, 默认值
  * high-performance: 高性能模式
  * low-power: 节能模式


## 2. 画布结果持久化 toDataURL, toBlob  
有一点需要特别注意：在 webgl 的 preserveDrawingBuffer 为 false 时， 只能在绘制动作当前的 event loop 中执行持久化，否则导出的内容是空的(黑图)。    
* toDataURL(type, quality)
type: 'image/png'（默认） | 'image/jpeg' | 'image/webp' (仅chrome支持)
quality: 默认 0.92， 0 - 1. 如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。  
图片的分辨率为96dpi。   
如果画布的高度或宽度是0，那么会返回字符串“data:,”。   
如果传入的类型非“image/png”，但是返回的值以“data:image/png”开头，那么该传入的类型是不支持的。   
* toBlob(callback, type, quality)


# canvas 的核心特性：

1. canvas 元素属于替换元素, 必须是以` <canvas></canvas> `(不同于`<img/>`) 形式处理，(虽然在React中会处理)。
2. 如果不设置宽度/高度，则默认宽度 300， 高度 150.
3. width/height 和 style 中的 width 和 height 的区别： 
* 属性 width/height 表示像素。
* style 中的 width/height 只表示显示视窗。 style 只会影响视觉，不会影响画布内容。   


4. 已验证：任何对 canvas 的 width 和 height 的写操作会导致 canvas 清空，即使值不会发生变化。 
5. 已验证：任何对 canvas 的 width 和 height 的写操作会导致 context 中的全局属性被重置。 
```js
var canvas = document.createElement('canvas');
console.log(canvas.width);
var ctx = canvas.getContext('2d');
ctx.globalAlpha = 0.5;
ctx.fillStyle = 'red';
canvas.width = 300;
console.log(ctx.globalAlpha, ctx.fillStyle);   // 1, "#000000", 默认的 fillStyle 是黑色
```

6. 已验证: 第一次调用 getContext 时是创建 context，后面每一次调用同类型的 getContext 获取的还是同一个 contenxt，即使传入的 contextAttributes 不同，也不会改变 context。     
```js
var ctx1 = canvas.getContext('2d', { alpha: false });
var ctx2 = canvas.getContext('2d', { alpha: true});
console.log(ctx1 === ctx2);       // true
ctx2.fillStyle = 'red';
ctx2.fillRect(10, 10, 30, 30);    // 整个画布是黑的， 行为还是 alpha: false
```

7. 一个画布只会存在一种 context。
```js
var ctx = canvas.getContext('2d');
var gl = canvas.getContext('webgl');      // null
```













## 问题


4. 坐标并不是和像素格子一一对应，坐标值可以为小数，imageData 的值只是渲染后的数据值。  
像素格子类似与围棋棋盘，坐标原点就是棋盘的左上角(0, 0). 对于没有完全落在像素格子里的颜色，透明度值会跟格子面积占比成正比。  






https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes


# best practice 
When a canvas is interactive, authors should include focusable elements in the element's fallback content corresponding to each focusable part of the canvas, as in the example above.

When rendering focus rings, to ensure that focus rings have the appearance of native focus rings, authors should use the drawFocusIfNeeded() method, passing it the element for which a ring is being drawn. This method only draws the focus ring if the element is focused, so that it can simply be called whenever drawing the element, without checking whether the element is focused or not first.

In addition to drawing focus rings, authors should use the scrollPathIntoView() method when an element in the canvas is focused, to make sure it is visible on the screen (if applicable).

Authors should avoid implementing text editing controls using the canvas element. Doing so has a large number of disadvantages:

Mouse placement of the caret has to be reimplemented.
Keyboard movement of the caret has to be reimplemented (possibly across lines, for multiline text input).
Scrolling of the text control has to be implemented (horizontally for long lines, vertically for multiline input).
Native features such as copy-and-paste have to be reimplemented.
Native features such as spell-checking have to be reimplemented.
Native features such as drag-and-drop have to be reimplemented.
Native features such as page-wide text search have to be reimplemented.
Native features specific to the user, for example custom text services, have to be reimplemented. This is close to impossible since each user might have different services installed, and there is an unbounded set of possible such services.
Bidirectional text editing has to be reimplemented.
For multiline text editing, line wrapping has to be implemented for all relevant languages.
Text selection has to be reimplemented.
Dragging of bidirectional text selections has to be reimplemented.
Platform-native keyboard shortcuts have to be reimplemented.
Platform-native input method editors (IMEs) have to be reimplemented.
Undo and redo functionality has to be reimplemented.
Accessibility features such as magnification following the caret or selection have to be reimplemented.
This is a huge amount of work, and authors are most strongly encouraged to avoid doing any of it by instead using the input element, the textarea element, or the contenteditable attribute.

