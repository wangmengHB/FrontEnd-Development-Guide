# 绘图样式





## 1. fillStyle, strokeStyle
有效值为 CSS 规范颜色值字符串, 渐变对象 或 pattern.
对于无效颜色值的写入动作，会忽略。  

## 2. globalAlpha  `[0 - 1]`
对于现有的已经设置好的 rgba 颜色，globalAlpha 会和它们进行乘法。  

## 3. 线型  
* lineWidth: 必须为正数，默认为 1.0. 
宽度为奇数的线不能精确呈现。

* lineCap:  butt | round | square, 默认 butt   
square: 端点处加上了等宽且高度为一半线宽的方块.  (两端加一起刚好是一个 square)  
round: 端点处加上以一半线宽为半径的半圆。  

* lineJoin:  round | bevel | miter, 默认 miter  
当值是 miter 的时候，线段会在连接处外侧延伸直至交于一点。   

* miterLimit: number
限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。 
超过这个长度，lineJoin 显示 bevel 效果。  

* getLineDash()  
返回一个包含当前虚线样式，长度为偶数的数组。

* setLineDash(segments)  
参数是一个Array数组。一组描述交替绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复。例如， [5, 15, 25] 会变成 [5, 15, 25, 5, 15, 25]。

* lineDashOffset: number, 初始值 0.0， 可以为负值。  
可以动态改变 lineDashOffset 实现蚂蚁线效果。   



# shadow
* shadowOffsetX = float / shadowOffsetY = float
shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。

* shadowBlur = float
shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。

* shadowColor = color
shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。

# 填充规则
当我们用到 fill（或者 clip和isPointinPath ）你可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。   
两个可能的值：
1. "nonzero": non-zero winding rule, 默认值. https://en.wikipedia.org/wiki/Nonzero-rule  
2. "evenodd":  even-odd winding rule. https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule     


# ctx.imageSmoothingEnabled 默认为 true  
在一个大的画布上显示几个像素的数据时，需要把 ctx.imageSmoothingEnabled 设置为 false， 否则视觉效果会是起毛的效果。
因为反锯齿默认是启用的，我们可能想要关闭它以看到清楚的像素。你可以通过切换勾选框来看到imageSmoothingEnabled属性的效果。

# 状态的保存和恢复 Saving and restoring state
* save(): 保存画布(canvas)的所有状态
* restore()
save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。
Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。一个绘画状态包括：
1. 当前应用的变形（即移动，旋转和缩放，见下）
2. strokeStyle, fillStyle, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalAlpha, globalCompositeOperation, imageSmoothingEnabled 的值
3. 当前的裁切路径（clipping path）

你可以调用任意多次 save 方法。每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。


# translate(x, y)
它用来移动 canvas 和它的原点到一个不同的位置。 
translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量。  
在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用 restore 方法比手动恢复原先的状态要简单得多。又，如果你是在一个循环中做位移但没有保存和恢复 canvas 的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出 canvas 范围以外了。

# rotate(angle)
它用于以原点为中心旋转 canvas。
这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。
旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。

# scale(x, y)
scale  方法可以缩放画布的水平和垂直的单位。两个参数都是实数，可以为负数，x 为水平缩放因子，y 为垂直缩放因子，如果比1小，会比缩放图形， 如果比1大会放大图形。默认值为1， 为实际大小。
画布初始情况下， 是以左上角坐标为原点的第一象限。如果参数为负实数， 相当于以x 或 y轴作为对称轴镜像反转（例如， 使用translate(0,canvas.height); scale(1,-1); 以y轴作为对称轴镜像反转， 就可得到著名的笛卡尔坐标系，左下角为原点）。

默认情况下，canvas 的 1 个单位为 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。

图片的 flip 过程实际上就是 1. 先 translate 到 一半的位置, 2. 再 scale，3. 然后再 drawImage。 

# transform(m11, m12, m21, m22, dx, dy)
这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，在这里我们用下面的矩阵：
```
m11 m21 dx
m12 m22 dy
0 	0 	1
```
如果任意一个参数是无限大，变形矩阵也必须被标记为无限大，否则会抛出异常。
这个函数的参数各自代表如下：
m11：水平方向的缩放   
m12：水平方向的倾斜偏移   
m21：竖直方向的倾斜偏移   
m22：竖直方向的缩放   
dx：水平方向的移动    
dy：竖直方向的移动    

* setTransform(m11, m12, m21, m22, dx, dy)
这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。如果任意一个参数是无限大，那么变形矩阵也必须被标记为无限大，否则会抛出异常。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。

* resetTransform()
重置当前变形为单位矩阵，它和调用以下语句是一样的：
```js
ctx.setTransform(1, 0, 0, 1, 0, 0);
```

# globalCompositeOperation
这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识12种遮盖方式的字符串。 默认是 source-over.   
globalCompositionOperation 的用法比较复杂，需要深入了解每一种效果以后再使用。  
详细请参考： https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Compositing     


# 裁切路径 clip 方法
将当前正在构建的路径转换为当前的裁剪路径。
我们使用 clip() 方法来创建一个新的裁切路径。  
默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。
clip 只会影响后续的绘制的结果，在执行完一个物体的绘制以后，可以将 clip 设置为整个画布进行恢复，然后进行后续的绘制。  



