# context 状态    

跟用笔在纸上作图的过程类似，canvas 代表着纸张，context 代表着我们手中的画笔和颜料盘。 
我们在生活中的作画过程，是可以在画布上面天马星空的作画，但是在计算机里，这个过程需要通过坐标系来完成。 
所以，除了样式以外，context 中还存在一个状态的概念来处理坐标变换。    

在设置绘图样式和状态的时候，通常需要将 context 的当前样式和状态保存起来，当绘图结束的时候，再把 context 的状态恢复到之前保存的状态。  
* save(): 保存画布的当前所有状态（所有样式和状态的一个快照）          
* restore(): 恢复到保存时的状态     
Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。
你可以调用任意多次 save 方法。每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。   


一个绘画状态包括：
1. 样式：   
* imageSmoothingEnabled       
* globalAlpha,    
* globalCompositeOperation,     
* fillStyle,           
* strokeStyle, lineWidth, lineCap, lineJoin, miterLimit, 虚线（lineDashOffset/setLineDash/getLineDash）     
* shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor,  
* font, textAlign,  textBaseline,   
2. 坐标变换状态（transform）        
3. 当前的裁切路径（clipping path）    


# 1. 绘图样式
## 1.1. imageSmoothingEnabled: 
只有在一个大的画布上显示几个像素的数据时，需要把 ctx.imageSmoothingEnabled 设置为 false， 否则视觉效果会是起毛的效果。
因为反锯齿默认是启用的，我们可能想要关闭它以看到清楚的像素。    
## 1.2. globalAlpha： `[0 - 1]`
当前画笔的透明度      
## 1.3. globalCompositeOperation： 
颜色合成模式，当前绘制颜色如何跟底色合成，默认为 "source-over", 就是我们最常见的，一个颜色自然叠加在另外一个颜色的算法。 
它的可选值有二十多种，具体请参考 [MDN](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation).    
在实际使用中，绝大部分场景并不需要设置它。但在 `fabric.js` 中只用到了三种 "destination-in", "destination-in", 和 "source-over"。      
destination-in： 表示保留底色部分，上层的绘制的图形颜色全部丢弃，视觉效果就是一个裁剪。   
destination-out: 底色和当前绘制图形相交的部分颜色全部丢弃。    

## 1.4. fillStyle, 
有效值为 CSS 规范颜色值字符串, 渐变对象 或 pattern. 对于无效颜色值的写入动作，会忽略。  

## 1.5. 线条样式     
* strokeStyle   
有效值为 CSS 规范颜色值字符串, 渐变对象 或 pattern. 对于无效颜色值的写入动作，会忽略。  

* lineWidth: 必须为正数，默认为 1.0. 
宽度为奇数的线不能精确呈现。    

关于线条样式的标准，请参考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors) 


* lineCap:  butt | round | square, 默认 butt   
square: 端点处加上了等宽且高度为一半线宽的方块.  (两端加一起刚好是一个 square)  
round: 端点处加上以一半线宽为半径的半圆。  

* lineJoin:  round | bevel | miter, 默认 miter  
当值是 miter 的时候，线段会在连接处外侧延伸直至交于一点。   

* miterLimit: number
限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。 
超过这个长度，lineJoin 显示 bevel 效果。  

* getLineDash(): 
返回一个包含当前虚线样式，长度为偶数的数组。      

* setLineDash(segments)  
参数是一个Array数组。一组描述交替绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复。例如， [5, 15, 25] 会变成 [5, 15, 25, 5, 15, 25]。    

* lineDashOffset: number, 初始值 0.0， 可以为负值。  
可以动态改变 lineDashOffset 实现蚂蚁线效果。   


## 1.6. 字体
* font:
* textAlign:    
* textBaseline: 


## 1.7. 阴影 shadow
* shadowOffsetX = float / shadowOffsetY = float
shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。

* shadowBlur = float
shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。

* shadowColor = color
shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。



# 2. 变换状态（本质就是用矩阵表示的坐标变换函数）       

## 2.1. translate(dx, dy)
它用来移动 canvas 和它的原点到一个不同的位置。 
translate 方法接受两个参数。dx 是左右偏移量，dy 是上下偏移量。  
```js
// 新的坐标：
x1 = x + dx;
y1 = y + dy;
```

## 2.2. rotate(delta)
它用于以原点为中心旋转 canvas。
这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。
旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。
```js
x1 = x * Math.cos(delta) - y * Math.sin(delta);
y1 = x * Math.sin(delta) + y * Math.cos(delta);
```

## 2.3. scale(scaleX, scaleY)
scale  方法可以缩放画布的水平和垂直的单位。两个参数都是实数，可以为负数，scaleX 为水平缩放因子，scaleY 为垂直缩放因子，如果比1小，会比缩放图形， 如果比1大会放大图形。默认值为1， 为实际大小。
画布初始情况下， 是以左上角坐标为原点的第一象限。如果参数为负实数， 相当于以x 或 y轴作为对称轴镜像反转（例如， 使用translate(0,canvas.height); scale(1,-1); 以y轴作为对称轴镜像反转， 就可得到著名的笛卡尔坐标系，左下角为原点）。

默认情况下，canvas 的 1 个单位为 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。

图片的 flip 过程实际上就是 1. 先 translate 到 一半的位置, 2. 再 scale，3. 然后再 drawImage。 

```js
x1 = x * scaleX;
y1 = x * scaleY;
```

## 2.4. transform(m11, m12, m21, m22, dx, dy)
在 css 中实际上还有一个 `skew()` 函数，这个在 context 中没有，但是它的结果可以通过 transform 得到。     

以上三种变换都可以使用 transform 方法来表示。  
这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，在这里我们用下面的矩阵：
```
m11   m21   dx
m12   m22   dy
0 	0   1
```
如果任意一个参数是无限大，变形矩阵也必须被标记为无限大，否则会抛出异常。
这个函数的参数各自代表如下：    
m11(a)：水平方向的缩放      
m12(b)：竖直方向的倾斜偏移       
m21(c)：水平方向的倾斜偏移      
m22(d)：竖直方向的缩放      
dx(e)：水平方向的移动    
dy(f)：竖直方向的移动    

```js
// 将变换展开就是如下, 完全可以表达上面三个变换以及他们的任意组合。  
x1 = x * m11 + y * m21 + dx;
y1 = x * m12 + y * m22 + dy;
```
当m11, m12, m21, m22 的关系满足正弦公式就是一个 rotate 行为。 
```js
ctx.setTransform(Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), dx, dy);
```

* getTransform():
获取当前的变换，返回一个 DOMMatrix 对象。  

* setTransform(m11, m12, m21, m22, dx, dy)
这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。如果任意一个参数是无限大，那么变形矩阵也必须被标记为无限大，否则会抛出异常。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。

* resetTransform()
重置当前变形为单位矩阵，它和调用以下语句是一样的：
```js
ctx.setTransform(1, 0, 0, 1, 0, 0);
```

## transform 的变换关系

### 1. skew(x, y)
skew 函数对应的 transform 矩阵是 `[1, tan(y), tan(x), 1, 0, 0]`
```
1  tan(x)    0
tan(y)    1   0
```

### 2. rotate(angel)
rotate 函数对应的 transform 矩阵 `[Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0]`
```
Math.cos(angle)   -Math.sin(angle)    0
Math.sin(angle)   Math.cos(angle)     0
```
rotate 只是 skew 的一种特例，skewX = - skewY 的时候就是一个旋转 + 缩放 `Math.sqrt(1^2 + tan(x)^2)`.  



### 3. 从 transform 中得到对应 angle，scale，skew
从计算机计算的角度直接使用 transform 的矩阵值，就可以直接描述变换了，但是矩阵上的数值，对于用户来说非常难以解释。   
对于用户来说，他所熟悉的图形动作就是一个 rotate / translate / scale 和一个简单的斜体（skew), 而且这是几个过程可能任意顺序组合。    
在图形库里，为了简化问题，我们需要定义几个属性值来描述图形变换，并且每一次属性值的变化都应该唯一对应一种结果。  
为了达成这种效果，我们可以把变换的过程给固定下来： 先旋转，缩放，平移（这三个是可逆矩阵，可以顺序无关）， 最后再 skew。        
（skew 是否是可逆矩阵需要自己数学证明一下）     

常见的定义属性：
```js
{
  angle: 0,
  scaleX: 1,
  scaleY: 1,
  flipX: false,
  flipY: false,
  skewX: 0,
  skewY: 0,
  translateX: 0,
  translateY: 0,
}
```
说明：实际上 scale 为负值的效果就是 flip, 但是我们在绘制图形的时候，通常还需要绘制这个图形的控制点，这些控制点也是在同一个 transform 状态中绘制，这样会导致控制点的绘制也被 flip 了。  所以这里的 scaleX 和 scaleY 只能为正值。  

不管这个 transform 矩阵是通过何种方式得到的，我们在还原的时候，完全可以按照容易解释的角度去还原（反正最终结果一样）。可以认为 skewY 的角度就是旋转角度 rotate 角度（因为它是顺时针方向）。 skewX 只是相对于于 skewY 的倾斜角度。   
通过以下矩阵乘法求解就可以得到 skewX 的值。  

```bash
# 旋转矩阵 A
(
  cos(angle), -sin(angle), 0
  sin(angle), cos(angle), 0,
  0,        0,           1,
)
# 缩放矩阵 B
(
  scaleX, 0, 0,
  0, scaleY, 0,
  0, 0, 1,
)
# skewY 矩阵 C
(
  1, 0, 0,
  tan(skewY), 1, 0,
  0, 0, 1,
)

# skewX 矩阵 C
(
  1, tan(skewX), 0,
  0, 1, 0,
  0, 0, 1,
)

```
通过 A * B * C = transform 求解，可以得到以下的结果。   
假定 skewY === 0， （因为 skewY 是为顺时针正方向）。  

```js
/**
 * Decomposes standard 2x3 matrix into transform components
 * suppose skewY === 0, then: 
 * a[0] === cos(angle) * scaleX
 * a[1] === sin(angle) * scaleX
 * a[0] * a[3] - a[2] * a[1] === scaleX * scaleY
 * a[0] * a[2] + a[1] * a[3] === (scaleX) ^ 2 * tan(skewX)
 * a[0] ^ 2 + a[1] ^ 2 === (scaleX) ^ 2
 */
export function decomposeMatrix2X3(a: Matrix2X3Array) {
  const angle = Math.atan2(a[1], a[0]);
  const scaleX = a[1] / Math.sin(angle);
  const scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX;  
  // const tanSkewX = (a[0] * a[2] + a[1] * a[3]) / (Math.pow(a[0], 2) + Math.pow(a[1], 2));
  const skewX = Math.atan2(a[0] * a[2] + a[1] * a[3], Math.pow(a[0], 2) + Math.pow(a[1], 2));

  return {
    angle: angle,
    scaleX: Math.abs(scaleX),
    scaleY: Math.abs(scaleY),
    skewX: skewX,
    skewY: 0,
    flipX: scaleX > 0? false: true,
    flipY: scaleY > 0? false: true,
    translateX: a[4],
    translateY: a[5]
  };
}
```
