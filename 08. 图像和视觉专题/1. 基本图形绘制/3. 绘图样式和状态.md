# context 状态    

跟用笔在纸上作图的过程类似，canvas 代表着纸张，context 代表着我们手中的画笔和颜料盘。 
我们在生活中的作画过程，是可以在画布上面天马星空的作画，但是在计算机里，这个过程需要通过坐标系来完成。 
所以，除了样式以外，context 中还存在一个状态的概念来处理坐标变换。    

在设置绘图样式和状态的时候，通常需要将 context 的当前样式和状态保存起来，当绘图结束的时候，再把 context 的状态恢复到之前保存的状态。  
* save(): 保存画布的当前所有状态（所有样式和状态的一个快照）          
* restore(): 恢复到保存时的状态     
Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。
你可以调用任意多次 save 方法。每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。   


一个绘画状态包括：
1. 样式：   
* imageSmoothingEnabled       
* globalAlpha,    
* globalCompositeOperation,     
* fillStyle,           
* strokeStyle, lineWidth, lineCap, lineJoin, miterLimit, 虚线（lineDashOffset/setLineDash/getLineDash）     
* shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor,  
* font, textAlign,  textBaseline,   
2. 坐标变换状态（transform）        
3. 当前的裁切路径（clipping path）    


# 1. 绘图样式
## 1.1. imageSmoothingEnabled: 
只有在一个大的画布上显示几个像素的数据时，需要把 ctx.imageSmoothingEnabled 设置为 false， 否则视觉效果会是起毛的效果。
因为反锯齿默认是启用的，我们可能想要关闭它以看到清楚的像素。    
## 1.2. globalAlpha： `[0 - 1]`
当前画笔的透明度      
## 1.3. globalCompositeOperation： 
颜色合成模式，当前绘制颜色如何跟底色合成，默认为 "source-over", 就是我们最常见的，一个颜色自然叠加在另外一个颜色的算法。 
它的可选值有二十多种，具体请参考 [MDN](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation).    
在实际使用中，绝大部分场景并不需要设置它。但在 `fabric.js` 中只用到了三种 "destination-in", "destination-in", 和 "source-over"。      
destination-in： 表示保留底色部分，上层的绘制的图形颜色全部丢弃，视觉效果就是一个裁剪。   
destination-out: 底色和当前绘制图形相交的部分颜色全部丢弃。    

## 1.4. fillStyle, 
有效值为 CSS 规范颜色值字符串, 渐变对象 或 pattern. 对于无效颜色值的写入动作，会忽略。  

## 1.5. 线条样式     
* strokeStyle   
有效值为 CSS 规范颜色值字符串, 渐变对象 或 pattern. 对于无效颜色值的写入动作，会忽略。  

* lineWidth: 必须为正数，默认为 1.0. 
宽度为奇数的线不能精确呈现。    

关于线条样式的标准，请参考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors) 


* lineCap:  butt | round | square, 默认 butt   
square: 端点处加上了等宽且高度为一半线宽的方块.  (两端加一起刚好是一个 square)  
round: 端点处加上以一半线宽为半径的半圆。  

* lineJoin:  round | bevel | miter, 默认 miter  
当值是 miter 的时候，线段会在连接处外侧延伸直至交于一点。   

* miterLimit: number
限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。 
超过这个长度，lineJoin 显示 bevel 效果。  

* getLineDash(): 
返回一个包含当前虚线样式，长度为偶数的数组。      

* setLineDash(segments)  
参数是一个Array数组。一组描述交替绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复。例如， [5, 15, 25] 会变成 [5, 15, 25, 5, 15, 25]。    

* lineDashOffset: number, 初始值 0.0， 可以为负值。  
可以动态改变 lineDashOffset 实现蚂蚁线效果。   


## 1.6. 字体
* font:
* textAlign:    
* textBaseline: 


## 1.7. 阴影 shadow
* shadowOffsetX = float / shadowOffsetY = float
shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。

* shadowBlur = float
shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。

* shadowColor = color
shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。



# 2. 变换状态     






# translate(x, y)
它用来移动 canvas 和它的原点到一个不同的位置。 
translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量。  
在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用 restore 方法比手动恢复原先的状态要简单得多。又，如果你是在一个循环中做位移但没有保存和恢复 canvas 的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出 canvas 范围以外了。

# rotate(angle)
它用于以原点为中心旋转 canvas。
这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。
旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。

# scale(x, y)
scale  方法可以缩放画布的水平和垂直的单位。两个参数都是实数，可以为负数，x 为水平缩放因子，y 为垂直缩放因子，如果比1小，会比缩放图形， 如果比1大会放大图形。默认值为1， 为实际大小。
画布初始情况下， 是以左上角坐标为原点的第一象限。如果参数为负实数， 相当于以x 或 y轴作为对称轴镜像反转（例如， 使用translate(0,canvas.height); scale(1,-1); 以y轴作为对称轴镜像反转， 就可得到著名的笛卡尔坐标系，左下角为原点）。

默认情况下，canvas 的 1 个单位为 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。

图片的 flip 过程实际上就是 1. 先 translate 到 一半的位置, 2. 再 scale，3. 然后再 drawImage。 

# transform(m11, m12, m21, m22, dx, dy)
这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，在这里我们用下面的矩阵：
```
m11 m21 dx
m12 m22 dy
0 	0 	1
```
如果任意一个参数是无限大，变形矩阵也必须被标记为无限大，否则会抛出异常。
这个函数的参数各自代表如下：
m11：水平方向的缩放   
m12：水平方向的倾斜偏移   
m21：竖直方向的倾斜偏移   
m22：竖直方向的缩放   
dx：水平方向的移动    
dy：竖直方向的移动    

* setTransform(m11, m12, m21, m22, dx, dy)
这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。如果任意一个参数是无限大，那么变形矩阵也必须被标记为无限大，否则会抛出异常。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。

* resetTransform()
重置当前变形为单位矩阵，它和调用以下语句是一样的：
```js
ctx.setTransform(1, 0, 0, 1, 0, 0);
```

# globalCompositeOperation
这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识12种遮盖方式的字符串。 默认是 source-over.   
globalCompositionOperation 的用法比较复杂，需要深入了解每一种效果以后再使用。  
详细请参考： https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Compositing     


# 裁切路径 clip 方法
将当前正在构建的路径转换为当前的裁剪路径。
我们使用 clip() 方法来创建一个新的裁切路径。  
默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。
clip 只会影响后续的绘制的结果，在执行完一个物体的绘制以后，可以将 clip 设置为整个画布进行恢复，然后进行后续的绘制。  



