# 空间点的表示
任何一个空间上的点，都包含了两个基本信息：坐标和像素值。
最简单的表示点的方法如下：
```js
let point = {
  coordinate: {
    x: 1,
    y: 1,
    z: 1,
    w: 1,   // 三维空间坐标通常会用一个 四维向量表示，w 为 1
  },
  color: {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
  }
}
```
# 问题 1：为什么需要用四维矢量，表示三维坐标？
由4个分量组成的矢量被称为齐次坐标，(x,y,z,w) 等价于 (x/w, y/w, z/w), 通常情况下 w 为 1.
因为有w的存在，如果w趋近于0，那么它所表示的点将趋近无穷远。
另外一个原因，三维点的变换需要用四维矩阵表示。

# 问题 2: 如何渲染三维空间的中的点
任何一个三维的图形最终都是要显示在一个二维有限宽高的画布上。在最终渲染的静态图上，必定会有一个维度的信息会丢失。
上面这句话这里面有两个重要的信息：
1. “丢失”的那个维度，在渲染过程中会当作深度值（而非坐标）来处理。
以z轴平行视角为例, 在(x,y)相同的情况下，视觉只能看到离自己最近的点，不能看到障碍物之后点。
2. 渲染空间是有范围限制的，在 webgl 中这个范围区间是 [-1.0, 1.0].
对于空间中的点的坐标来说，它的位置坐标并没有这个[-1.0, 1.0]的限制，但只有当它落在这个区间内，才会被渲染。
总结：3D图形的渲染机制可以理解为一个 [-1.0, 1.0] 的三维渲染空间，(x, y) 对应渲染的坐标位置，z轴对应深度值。
三维渲染的过程可以用下面这个demo表示：
https://github.com/wangmengHB/simple-3D-demos/tree/master/src/demo1

# 三维空间点的渲染: 投影
3D图形渲染的核心内容，就是空间变换，从三维空间点到三维渲染空间的投影过程。

## 方法1: 正交投影
这种投影是最简单的，只有落在 [-1.0, 1.0]空间的点会被渲染出来。渲染方法同上。
可以简单认为它是默认投影，无投影计算。
这种方法实现的3D效果，只适用于固定摄像机的场景，类似跳一跳/红警2/保卫萝卜之类的游戏。
不能用于第一人称的场景，因为正交投影渲染的效果，没有距离感。

## 方法2: 球面坐标系
假定人眼是空间中的一个点，我们所看到的周围的物体景象，实际上可以理解为：相对于人眼的球面投影。
```js
x1 = Math.atan(x/z);
y1 = Math.atan(y/z);
z1 = Math.hypot(x, y, z);
```
这里的 x1 是角度单位, 表示水平方向偏移的度数（弧度）, y1 表示竖直方向偏移的度数，z1 表示物体点到人眼的距离。
在渲染的过程中，只需要选取一个有效的视角范围（小于180度），z1值按深度处理处理即可。
这种方案在静态全景图里面应用还是很普遍的。
1. 全景图应用demo：
https://github.com/wangmengHB/simple-3D-demos/tree/master/src/demo2
2. 使用球面坐标投影的demo：
https://github.com/wangmengHB/simple-3D-demos/tree/master/src/demo3

球面坐标投影有几个先天的缺陷：
1. 一次投影计算的结果是全部360度视野结果，大部分的计算结果会被丢弃，并不会用在渲染过程中，效率太低。（fov）
2. 每一次计算需要把整个场景中所有点都纳入计算范围，即使距离非常远的点。(far)
3. 对于z为0的面无法表达，因为分母为0，这些面上所有点，都会被认为是水平90，竖直90度，实际上并不是。(near)
4. x1, y1 的单位是角度，z1 的单位是长度，单位是不统一的。
5. 这种变换是非线性的，无法用矩阵来表达这种变换
6. 渲染的过程不能复用，需要修改定制。

为了解决这个问题，更普遍的做法是采用透视投影 perspective projection.

## 方法3: 透视投影
透视投影是3D渲染中使用得最多的投影计算。具体原理如下：
假定人的眼睛是一个手电筒，它的光束在near（最近距离）到far（最远距离）之间可以穿透任何物体，那么这一块投射区域就是可见的渲染区。它的形状是没有顶部部分的金字塔。
如果把这下半部分金字塔形状内的所有空间点，都转换到[-1, 1]渲染空间（规则的立方体）中, 然后可以复用之前提到的渲染逻辑了，把图形渲染出来。
同样对于下半部分金字塔形状的之外的点，应该都转换到[-1, 1]渲染空间之外，具体值是多少不重要，因为无论为何值，都不会参与渲染。
假定把这个半金字塔形状的空间按光线方向垂直切为 n 个面，这里的每一个面都是一个完整的矩形。
如果这个空间只有一个有效的面，那个这个面会完整的绘制在一个同样尺寸画布上。
对于离near 越近的面，它的 x，y轴会被拉伸，对于离far越近的点，它的 x，y轴会被压缩。
（类似于美术课上，老师教给我们的那铅笔头估计远处景物的尺寸）

我们现在需要的就是这样一个透视投影计算，把上述的逻辑表达出来：
```js
x1 = x / (aspect * z * Math.tan(fov/2));
y1 = y / (z * Math.tan(fov/2));
z1 = z * ((-2)/(n - f)) + (-(3*n -f)/(n - f)) ;
w1 = 1;
```

# 小结
利用以上原理，即使没有webgl的帮助，我们一样能够绘制出的普通的3D图形，虽然它的性能很差。
实际上，如果在改善性能，并行计算，以及到点/线/面绘制的各个过程继续深挖下去，我们可以初步推导出 webgl 更深层次的设计和工作原理。
最简单的事情，从优化内存开始，上述所有例子中，是用对象的方式来表示空间点，虽然直接，但是非常浪费内存，实际中更多的是使用连续内存的类型化数组。
这就是下一节的：矢量和矩阵（类型化数组）。
