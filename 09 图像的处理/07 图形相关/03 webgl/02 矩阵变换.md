# 最简单的转换
## 1. 平移
```js
`
attribute vec4 aPosition;
uniform vec4 uTranslation;

void main () {
    gl_Position = aPosition + uTranslation;
}
`
const uTranslation = gl.getUniformLocation(gl.program, 'uTranslation')
gl.uniform4f(0.5, 0.0, 0.0, 0.0)

```

## 2. 旋转（z轴）
```js
`
attribute vec4 aPosition;
uniform float uCosB, uSinB;

void main () {
    gl_Position.x = aPosition.x * uCosB - aPosition.y * uSinB;
    gl_Position.y = aPosition.x * uSinB + aPosition.y * uCosB;
    gl_Position.z = aPosition.z;
    gl_Position.w = 1.0;
}
`

const uCosB = gl.getUniformLocation(gl.program, 'uCosB')
const uSinB = gl.getUniformLocation(gl.program, 'uSinB')
gl.uniform1f(uCosB, Math.cos(xx))
gl.uniform1f(uSinB, Math.sin(xx))

```
说明：
1. 获取vec4中变量的分量: x, y, z, w
2. 着色器中的+运算，是默认支持向量运算的.

# 矩阵变换
变换矩阵在三维计算机图形学中应用很广泛，着色器本身就实现了矩阵和矢量相乘的功能.
webGl和openGl中的矩阵都是按照以列为主序的方式存放在一维数组Float32Array中的.
例子：按z轴旋转的矩阵：
```js
// 数学中真实矩阵如下：
[
    cosB, -sinB, 0, 0,
    sinB,  cosB, 0, 0,
       0,     0, 1, 0,
       0,     0, 0, 1,
]
// 传递给着色器的顺序为：
new Float32Array([
    cosB, sinB, 0.0, 0.0,
    -sinB, cosB, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0,
])

```


```js
`
attribute vec4 aPosition;
uniform mat4 uModelMatrix;

void main () {
    gl_Position = uModelMatrix * aPosition;
}
`

let angle = 90.0
let radian = Math.PI * angle / 180.0
let cosB = Math.cos(radian), sinB = Math.sin(radian)
const modelMatrix = new Float32Array([
    cosB, sinB, 0.0, 0.0,
    -sinB, cosB, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0,
])
const uModelMatrix = gl.getUniformLocation(gl.program, 'uModelMatrix')
gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix)
```

gl.uniformMatrix4fv(location, transpose, array)
第二个参数transpose,表示是否转置矩阵，即交换矩阵的行和列. 因为webGL没有实现矩阵转置的方法，所以这个参数只能为false.

平移矩阵如下：(以列为主序)
```js
new Float32Array([
    1.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
      x,   y,   z, 1.0
])
```

# 复合矩阵运算
对于多个变换叠加的结果可以用数学表达式： R = A * (B * vec4)
可以很容易证明： A * (B * vec4) === (A * B) * vec4
但是 A 和 B 的顺序是不能颠倒的，先旋转再平移和先平移再旋转的结果是不一样的. B变换在先，A变换在后.
在github上有一个矩阵变换运算的util库：https://github.com/toji/gl-matrix
