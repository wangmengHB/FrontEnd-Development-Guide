# 空间变换 transform
任何一个复杂的图形变换都可以分解为一系列基本的变换的组合，例如：平移，缩放，旋转。这些基本变换都可以用线性的数学公式表达：
1. 平移
```js
x1 = x + dx;  // dx 表示 x 轴方向的平移量
y1 = y + dy;
z1 = z + dz;
w1 = 1;

// 封装成函数
function translate(dx, dy, dz) {
  return function(point) {
    const {x, y, z, w} = point.coordinate;
    point.coordinate.x = x + dx;
    point.coordinate.y = y + dy;
    point.coordinate.z = z + dz;
  }
}
```
2. 缩放
```js
x1 = x * sx;    // sx 表示 x 轴方向的缩放比
y1 = y * sy;
z1 = z * sz;
w1 = 1;

function scale(sx, sy, sz) {
  return function(point) {
    const {x, y, z, w} = point.coordinate;
    point.coordinate.x = x * sx;
    point.coordinate.y = y * sy;
    point.coordinate.z = z * sz;
  }
}

```
3. 旋转
旋转的操作稍微复杂一点，需要简单的数学推导推理一下，才能变为线性表达式。
以z轴方向旋转为例，z轴变换后的坐标不变，x，y坐标值应该如下：
```js
let r = Math.hypot(x, y);
let originAngle = Math.acos(x / r);   // In Math, Math.asin(x / r) equals Math.asin(y / r)
x1 = r * Math.cos(originAngle + delta);
y1 = r * Math.sin(originAngle + delta);
```
从表面上看，这个变换是非线性的，但实际上只需要利用一下简单的三角函数公式，就可以将上述计算变为线性方式.
```
cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b);
sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b);
```
更加直观的公式证明推导图如下：
![sin(a - b)推导](/sinA-B-proof.png)

```js
x1 = x * Math.cos(delta) - y * Math.sin(delta);
y1 = x * Math.sin(delta) + y * Math.cos(delat);
z1 = z;
w1 = 1;

function rotateZ(angle) {
  return function(point) {
    const {x, y} = point.coordinate;
    point.coordinate.x = x * Math.cos(angle) - y * Math.sin(angle);
    point.coordinate.y = x * Math.sin(angle) + y * Math.cos(angle);
  }
}
```
通过上述三个基本的空间变换组合，可以得到任意复杂的空间变换(比如先z轴旋转，再平移，再缩放)，表现形式如下：
```js
scale(sx, sy, sz)(translate(dx, dy, dz)(rorateZ(angle)(point)));
```
很明显地可以看出缺陷：
1. 无论怎样设计变换函数的形式，最终得到的都是一个类似这样层层嵌套的形式。
2. 上述例子中，任何一种组合变换都对应生成了一个新的组合函数，即使只是一个参数的变化。
3. 组合变换无法用持久化的方式来表达，变换步骤无法共享。

为了解决以上问题，应该使用矩阵来表式变换，而不是函数。
相对于函数而言，矩阵可以用少量的数字描述大量的空间中的变换，并且能轻易地在程序间共享。
矩阵的真正厉害之处在于矩阵的组合。当一组特定类型的矩阵连乘起来，它们保留了变换的经过并且是可逆的。
这意味着如果平移、旋转和缩放矩阵组合在一起，当我们使用逆变换并颠倒应用的顺序，可以得到原来的点。

注意：webgl（包括openGL）的矩阵都是以列为主序，这个和数学教材上的默认顺序不同。
原因很简单，矢量一定是按列排列，矢量是用数组表示。 矩阵也是用数组存储，为了保证数组位置统一，所以矩阵也是以列为主序。

# 矩阵的基本运算
1. 矩阵 * 向量 (在实际使用中，应该使用类型化数组来提升性能)
```js
function multiplyMatrixAndVector(mat4, vec4) {
  const [
    c0r0, c0r1, c0r2, c0r3,     // 第一列
    c1r0, c1r1, c1r2, c1r3,     // 第二列
    c2r0, c2r1, c2r2, c2r3,     // 第三列
    c3r0, c3r1, c3r2, c3r3,     // 第四列
  ] = mat4;
  const [x, y, z, w] = vec4;
  const resultX = (c0r0 * x) + (c1r0 * y) + (c2r0 * z) + (c3r0 * w);
  const resultY = (c0r1 * x) + (c1r1 * y) + (c2r1 * z) + (c3r1 * w);
  const resultZ = (c0r2 * x) + (c1r2 * y) + (c2r2 * z) + (c3r2 * w);
  const resultW = (c0r3 * x) + (c1r3 * y) + (c2r3 * z) + (c3r3 * w);
  return [resultX, resultY, resultZ, resultW]
}
```
2. 矩阵 * 矩阵
gl-matrix 中的矩阵乘法运算的实现：https://github.com/toji/gl-matrix
```js
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
export function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}
```

# 空间变换的矩阵表示
## 常规矩阵
1. 平移
```js
const translateMatrix = [
  1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  x, y, z, 1
];
```
2. 缩放
```js
const scaleMatrix = [
    w,    0,    0,   0,
    0,    h,    0,   0,
    0,    0,    d,   0,
    0,    0,    0,   1
];
```
3. 旋转
```js
function rotateAroundXAxis(a) {
  return [
       1,       0,        0,     0,
       0,  cos(a),    sin(a),     0,
       0,  -sin(a),   cos(a),     0,
       0,       0,        0,     1
  ];
}

function rotateAroundYAxis(a) { 
  return [
     cos(a),   0, -sin(a),   0,
          0,   1,      0,   0,
     sin(a),   0, cos(a),   0,
          0,   0,      0,   1
  ];
}

function rotateZ(a) {
  return [
    cos(a),   sin(a),    0,    0,
    -sin(a),  cos(a),    0,    0,
         0,       0,    1,    0,
         0,       0,    0,    1
  ];
}

```

## 投影矩阵
```js
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
export function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = (2 * far * near) * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
```



* 小技巧：使用css中的 matrix3d 特性
```js
// 从矩阵数组创建matrix3d样式属性
function matrixArrayToCssMatrix(array) {
  return "matrix3d(" + array.join(',') + ")";
}
// 获取DOM元素
const ele = document.getElementById('some-ele-id');
// 返回结果如："matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 50, 100, 0, 1);"
const matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 50, 100, 0, 1];
const matrix3dRule = matrixArrayToCssMatrix( matrix );
// 设置变换
moveMe.style.transform = matrix3dRule;
```





# 向量表示
定义两个类型化数组（内存是连续的），一个数组表示坐标，一个数组表示颜色。
这里两个数组实际就是对应于 webgl 中的两个着色器：（坐标数组）顶点着色器 和 （颜色数组）片元着色器。
```
# 坐标
[ x1, y1, z1, w1,   x2, y2, z2, w2,   x3, y3, z3, w3,   ...]
# 颜色
[ r1, g1, b1, a1,   r2, g2, b2, a2,   r3, g3, b3, a3,   ...]
```
这两组信息之间的关联关系是靠数组中的位置来决定的。而并非是靠一个对象关联在一起（上一节）。
当空间的点的坐标发生了变化，空间点在数组中的位置是不变的。
```
# 第一个点的坐标发生了变化，但是它在 坐标数组和颜色数组中的位置不会变化，(r1,g1,b1,a1)仍然是该点的颜色
# 坐标
[ x'1, y'1, z'1, w'1,   x'2, y'2, z'2, w'2,   x'3, y'3, z'3, w'3,   ...]
# 颜色
[ r1, g1, b1, a1,   r2, g2, b2, a2,   r3, g3, b3, a3,   ...]
```

经过这样的优化以后，3D图形的绘制, 只需要关注这两个数组即可，最简单的方法：
1. 确定视角方向，
2. 根据这两个数组把所有点都画出来，视角方向最近的点绘制在上面.
（这里暂时忽略纹理的绘制。）

