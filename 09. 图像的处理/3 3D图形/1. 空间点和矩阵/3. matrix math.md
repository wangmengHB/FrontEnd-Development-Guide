https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Matrix_math_for_the_web


# 变换矩阵
所有的空间变换（比如，平移，缩放，旋转等）都可以用矩阵来表示，对于三维的空间变换通常使用一个4x4方阵矩阵表示，共16个值组成。
对于三维空间多出来的一维是，需要设为1。（对于三维空间的点，需要用四维矩阵来表示变换）。
因为矩阵运算多为GPU并行计算，偶数位的运算，性能最优。
注意：在矩阵数组中是以列为单位排列的！！！因为向量都是为列。

矩阵之所以重要，是因为它可以用少量的数字描述大量的空间中的变换，并且能轻易地在程序间共享。矩阵可以不同的坐标空间，甚至一些矩阵乘法可以将一组数据从一个坐标空间映射到另一个坐标空间。矩阵能够高效率地保存生成它们的每一步变换。

对于在WebGL中使用，显卡尤其擅长大量的点乘矩阵运算。各种各样的运算，如点定位、光线运算、动态角色，都依赖这个基础工具。


# 矩阵的基本运算
1. 矩阵 * 向量 (在实际使用中，应该使用类型化数组来提升性能)
```js
function multiplyMatrixAndVector(mat4, vec4) {
  const [
    c0r0, c0r1, c0r2, c0r3,     // 第一列
    c1r0, c1r1, c1r2, c1r3,     // 第二列
    c2r0, c2r1, c2r2, c2r3,     // 第三列
    c3r0, c3r1, c3r2, c3r3,     // 第四列
  ] = mat4;
  const [x, y, z, w] = vec4;
  const resultX = (c0r0 * x) + (c1r0 * y) + (c2r0 * z) + (c3r0 * w);
  const resultY = (c0r1 * x) + (c1r1 * y) + (c2r1 * z) + (c3r1 * w);
  const resultZ = (c0r2 * x) + (c1r2 * y) + (c2r2 * z) + (c3r2 * w);
  const resultW = (c0r3 * x) + (c1r3 * y) + (c2r3 * z) + (c3r3 * w);
  return [resultX, resultY, resultZ, resultW]
}
```
2. 矩阵 * 矩阵
gl-matrix 中的矩阵乘法运算的实现：
https://github.com/toji/gl-matrix
```js
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
export function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}
```



# 矩阵组合





# 用矩阵操作DOM

一个非常简单的开始使用矩阵的方法是使用CSS3里的matrix3d变换。首先， 我们新建一个简单的<div>并加上一些内容。这里样式没有展示出来，但我们将其设置成了页面居中且固定宽度与高度。我们同样为变换设定了动画以便清晰的观察发生的变化。
```js
// 从矩阵数组创建matrix3d样式属性
function matrixArrayToCssMatrix(array) {
  return "matrix3d(" + array.join(',') + ")";
}
	
// 获取DOM元素
var moveMe = document.getElementById('move-me');

// 返回结果如："matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 50, 100, 0, 1);"
var translationMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 50, 100, 0, 1];
var matrix3dRule = matrixArrayToCssMatrix( translationMatrix );

// 设置变换
moveMe.style.transform = matrix3dRule;
```


