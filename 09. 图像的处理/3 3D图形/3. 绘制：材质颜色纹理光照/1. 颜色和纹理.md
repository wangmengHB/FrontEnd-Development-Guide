173 -213 颜色和纹理
247 - 501 

7. 进入三维世界
8. 光照
9. 层次模型
10. 高级技术


# 问题

2. 图形到片元的转化，图元光栅化(rasterzation process)
3. 将图像(或纹理)映射到图形或三维对象的表面上




# 1. 将非坐标数据传入顶点着色器
* 示例1: 将多个点的尺寸传递给顶点着色器
```js
var VERTEX_SHADER_SOURCE = `
 attribute vec4 a_Position;
 attribute float a_PointSize;
 void main() {
   gl_Position = a_Position;
   gl_PointSize = a_PointSize;
 }
`;

let vertices = new Float32Array([
  0.0, 0.5,       // 第一个点
  -0.5, -0.5,     // 第二个点
  0.5, -0.5       // 第三个点
]);

let sizes = new Float32Array([
  10.0, 20.0, 30.0
]);

let vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bindData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
let a_Position = gl.getAttributeLocation(gl.program, 'a_Position');
gl.vertexAttribPointer(a_Position, 2, gl.Float, false, 0, 0);
gl.enableVertexAttribArray(a_Position);

let sizeBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
gl.bindData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);
let a_PointSize = gl.getAttributeLocation(gl.program, 'a_PointSize');
gl.vertexAttribPointer(a_PointSize, 1, gl.Float, false, 0, 0);
gl.enableVertexAttribArray(a_PointSize);
```
WebGl 允许我们把顶点的坐标和尺寸打包到同一个缓冲区对象中，并通过某种机制分别访问缓冲区对象中不同类型的数据。
比如，交错方式 (interleaving).
```js
let verticesSizes = new Float32Array([
  0.0, 0.5, 10.0,   // 第一个点： x， y， size
  -0.5， -0.5， 20.0，
  0.5， -0.5， 30.0
]);
let FSIZE = verticesSizes.BYTES_PER_ELEMENT;  // 每一个元素的字节数
let vertexSizeBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexSizeBuffer);
gl.bindData(gl.ARRAY_BUFFER, verticesSizes, gl.STATIC_DRAW);
let a_Position = gl.getAttribLocation(gl.program, 'a_Position');
gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 3, 0);
gl.enableVertexAttribArray(a_Position);
let a_PointSize = gl.getAttribLocation(gl.program, 'a_PointSize');
gl.vertexAttribPointer(a_PointSize, 1, gl.FLOAT, false, FSIZE * 3, FSIZE * 2);  // 从第一组的第三个元素开始
gl.enableVertexAttribArray(a_PointSize);
```

* 示例2: 设置点的颜色
颜色数据也需要先传递给顶点着色器，再由顶点着色器传递给片元着色器。
varing 变量的作用是 从顶点着色器 向 片元着色器 传输数据。
```js
let VERTEX_SHADER_SOURCE = `
attribute vec4 a_Position;
attribute vec4 a_Color;
varing vec4 v_Color;

void main() {
  gl_Position = a_Position;
  gl_PointSize = 10.0;
  v_Color = a_Color;
}
`;
let FRAGMENT_SHADER_SOURCE = `
varing vec4 v_Color;

void main() {
  gl_FragColor = v_Color;
}
`;
let verticesColors = new Float32Array([
  0.0, 0.5, 1.0, 0.0, 0.0,    // 第一个点：x, y, r, g, b
  -0.5, -0.5, 0.0, 1.0, 0.0,
  0.5, -0.5, 0.0, 0.0, 1.0
]);
let vertexColorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
gl.bindData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);
const FSIZE = verticesColors.BYTES_PER_ELEMENT;
let a_Position = gl.getAttribLocation(gl.program, 'a_Position');
gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 5, 0);
gl.enableVertexAttribArray(a_Position);
let a_Color = gl.getAttribLocation(gl.program, 'a_Color');
gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 5, FSIZE * 2);
gl.enableVertexAttribArray(a_Color);

```








通过顶点的每种数据建立一个缓冲区，然后分配给对应的attribute变量，这样就可以向顶点着色器传递多份逐顶点的数据信息了，如：
顶点尺寸，顶点颜色，顶点纹理坐标，点所在平面的法向量等等.
webGL允许我们把顶点的坐标和尺寸数据打包到同一个缓冲区对象中，并通过某种机制分别访问缓冲区对象中的不同种类的数据.
即，使用gl.vertexAttribPointer()的第五个参数stride和第六个参数offset.