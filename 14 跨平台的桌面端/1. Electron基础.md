# Electron
Electron 是由三部分组成：Chromium，nodejs，操作系统兼容部分。
操作系统兼容这部分的工作是Electron内部解决的，对于开发者来说并不需要关心。开发者需要关注的只有两部分：Chromium 和 nodejs。

## Chromium
Chromium有很多开源的版本，不同的版本之间会有一些差异，Electron使用的是Chromium Content Module. 它是浏览器的核心部分，包含Blink渲染引擎，自己的V8引擎（非nodjes部分的v8引擎）。
CCM 只关于核心需求：渲染网页。对于其他的浏览器特性：Chrome扩展插件，同步Chrome书签等，它是不支持的。


## Electron 的优点：
1. 和native的程序一样：
对话框和右键菜单可以是native的，支持文件拖拽。文件名后缀关联启动。支持系统通知。
2. 相对于浏览器的安全限制，Electron的运行环境更宽松。
3. 离线优先设计

## Electron 如何工作：
1. 两个进程：主进程和渲染进程
只有主进程可以访问本地系统资源，它是nodejs环境。（包含native对话框，native菜单等）
系统的剪切板可以被两个进程都访问。
渲染进程是由主进程启动。
不同于传统的web应用，渲染进程也可以访问已安装的node modules。
2. 主进程 app instance 的事件：
ready:  
window-all-closed:  Mac OS （platform: darwin）可以关闭所有的窗体但不退出应用。
activate: 
3. 渲染进程： 在渲染进程的html环境中是可以访问nodejs环境，比如 process API. 


## BrowserWindow 基础
1. ready-to-show event: 
```js
const win = new BrowserWindow({show: fasle});
win.once('ready-to-show', () => win.show()); 
```
2. BrowserWindow 构造函数的默认配置：
```js
{
  show: true,
  backgroundColor: '#FFF', // 不能是rgb（）或者rgba（）格式，只支持这一种格式
  width: 800,
  height: 600,
  minWidth: 0,
  minHeight: 0,
  maxWidth: UNLIMITED,
  maxHeight: UNLIMITED,
  resizable: true,
  movable: true,
  alwaysOnTop: false,
  frame: true, // 如果设置为false，则窗体没有边框，没有关闭/最大化等按钮
  // 在macOS下，不使用frame属性，而是使用 'hidden' 或 'hidden-inset'
  // 可以让关闭/最大化按钮显示，而不显示标题栏.
  // 在windows系统上，titleBarStyle 属性无效
  titleBarStyle: 'default',
  transparent: false, 
  // 如果需要设置为 true，则需要去掉 backgroundColor 属性
  // 可以在html中设置背景色半透明
  
}
```
当窗体创建后，还可以通过以下方法修改：setBounds(bounds), setSize(width, height), setMinimumSize(width, height), setMaximumSize(width, height).
如果设置了x,y属性，则center会自动置为
title属性：当html中的title为空时，这时title属性才会生效。
对于frameless window，只能通过css方法解决，比如：
```html
<body style="-webkit-app-region: drag">
```
但是这样的缺陷是，整个页面的事件都被拦截，正确的做法是在某个元素上加上这个。
当然，movable: false 的优先级是最高的。

## 本地菜单
```js
const Menu = require('electron').Menu;
app.on('ready', function () {
  const menu = Menu.buildFromTemplate(/*菜单模板*/template);
  Menu.setApplicationMenu(menu);
  createWindow();
});
```
1. 菜单模板示例
```js
if (process.platform === 'darwin') {
  const name = electron.app.getName();
  template.unshift({
    label: name,
    submenu: [
      {
        label: 'About',
        role: 'about'
      }, 
      {
        type: 'seperator',
      }, 
      {
        label: 'Quit',
        accelerator: 'Command+Q',
        click: function (menuItem, browserWindow, event) {
          app.quit();
        }
      }
    ]
  })
}
```
2. accelerator: (和键盘对应的快件键)
Command: (Cmd)
Control: (Ctrl)
CommandOrControl: (CmdOrCtrl)
Alt:
Option:
AltGr: 键盘右手侧的 Alt键
Shift:
Super: 在windows系统上表示win键，在Mac上表示Command键

3. role: role表示built-in的菜单行为，不需要自己再实现click函数
undo | redo | cut | copy | selectall | delete
paste | pasteandmatchstyle
minimize | togglefullscreen
close: close current window
quit
reload
toggledevtools
resetzoom
zoomin: 放大10%
zoomout: 缩小10%
在mac下，role 还可以为以下值：
about | hide | hideothers | unhide
startspeaking | stopspeaking
front | zoom 
window: submenu 是 window menu  
help: submenu 是 help menu   
services submenu 是 services menu   
对于自定义的函数: (menuItem, browserWindow, event) => {}   
4. menu的其他属性：enable， visible  
5. type：checkbox | radio

## contextual menu  128 - 131
两种方案：
1. 在渲染进程中创建contextual menu
```js
const { remote } = require('electron');
const { Menu } = remote;
const myContextMenu = Menu.buildFromTemplate([
  { label: 'Cut', role: 'cut' },
  { label: 'Copy', role: 'copy' },
]);
window.addEventListener('contextmenu', (event) => {
  event.preventDefault();
  myContextMenu.popup()
});
```
2. 使用IPC，更推荐这种做法，让所有菜单相关的代码都在主进程中

主进程：  
```js
const { Menu, MenuItem, ipcMain, BrowserWindow } = require('electron');
const myContextMenu = new Menu();
myContextMenu.append(new MenuItem({label: 'Cut', role: 'cut'}));
myContextMenu.append(new MenuItem({label: 'Copy', role: 'copy'}));

ipcMain.on('show-context-menu', function(event) {
  const win = BrowserWindow.fromWebContents(event.sender);
  myContextMenu.popup(win);
});
```
渲染进程中：
```js
const { remote, ipcRenderer } = require('electron');
const ipc = ipcRenderer;
window.addEventListener('contextmenu', (event) => {
  event.preventDefault();
  ipc.send('show-context-menu');
})
```
